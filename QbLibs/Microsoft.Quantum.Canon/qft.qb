// namespace Microsoft.Research.Qflat.CliffordTRzMachine
// FIXME: uncomment when the namespace syntax is clarified

/// <summary>
/// Apply the Quantum Fourier Transform (QFT) to a quantum register. 
/// </summary>
/// </param name = "qs"> Qubit[] = quantum register. </param>
/// <remarks> QFT requires Z-rotation gates of the form 2π/2ᵏ and Hadamard gates. The 
/// input is assumed to be encoded in little endian, the output is returned in little endian. 
/// <remarks>
operation () QFT ( Qubit[] qs ) =
{
	body {
		let n = length(qs)
		if ( n == 0 )
		{ 
			fail 'function register qs requires at least 1 qubit.' 
		}
		for (i in 0..(n/2-1)) { // remove this loop for big endian -> little endian
		    CNOT (qs[i], qs[n-i-1])
	        CNOT (qs[n-i-1], qs[i])
	        CNOT (qs[i], qs[n-i-1])
		}
    	for (i in 0..n-1) {
    		for (j in 0..(i-1)) {
    			controlled([qs[i]]) RFrac(ZPauli, 1, 2^(i-j), qs[j])
    			H(qs[i])
			}
		}
}

/// <summary>
/// Apply the Approximate Quantum Fourier Transform (AQFT) to a quantum register. 
/// </summary>
/// </param name = "qs"> Qubit[] = quantum register. </param>
/// </param name = "a"> Int = approximation parameter. </param>
/// <remarks> AQFT requires Z-rotation gates of the form 2π/2ᵏ and Hadamard gates. The 
/// input is assumed to be encoded in big endian, the output is return in little endian. 
/// The approximation parameter a determines the pruning level of the Z-rotations, i.e., 
/// a ∈ {0..n} and all Z-rotations 2π/2ᵏ where k≧a are removed from the QFT circuit. It
/// is known that for k >= log₂(n)+log₂(1/ε)+3 one can bound ||QFT-AQFT||<ε. 
/// [ M. Roetteler, Th. Beth, Appl. Algebra Eng. Commun. Comput. 19(3): 177-193 (2008) ]
/// [ D. Coppersmith, https://arxiv.org/abs/quant-ph/0201067 ]
/// <remarks>

operation () ApproximateQFT ( Qubit[] qs, Int a ) =
{
	body {
		let n = length(qs)
		if ( n == 0 )
		{ 
			fail 'function register qs requires at least 1 qubit.' 
		}
		if ( k < 0 || k > n )
		{
			fail 'approximation parameter a must be in {0..n}'
		}
    	for (i in 0..(n/2-1)) { // remove this loop for big endian -> little endian
		    CNOT (qs[i], qs[n-i-1])
	        CNOT (qs[n-i-1], qs[i])
	        CNOT (qs[i], qs[n-i-1])
		}
		for (i in 0..n-1) {
    		for (j in 0..(i-1)) {
    			if (i-j) < k ) 
				{
					controlled([qs[i]]) RFrac(ZPauli, 1, 2^(i-j), qs[j])	
				}
    			H(qs[i])
			}
		}
}
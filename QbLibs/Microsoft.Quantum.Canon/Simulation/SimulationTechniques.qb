namespace Microsoft.Quantum.Canon {
    open Microsoft.Quantum.Primitive
    
//For Trotterization
operation ApplyEvolutionImpl(evolutionGenerator: EvolutionGenerator, idx : Int, stepsize: Double, qubits: Qubit[]) : () {
    Body{
        let (evolutionSet, generatorSystem) = evolutionGenerator
        let (nTerms, generatorSystemFunction) = generatorSystem
        let (generatorIndex, coefficient) = generatorSystemFunction(idx)
        (evolutionSet(generatorIndex))(coefficient * stepsize, qubits)
    }
    Adjoint auto
    Controlled auto
    Controlled Adjoint auto
}

function TrotterStep(evolutionGenerator: EvolutionGenerator, trotterOrder: Int, trotterStepSize: Double) : (Qubit[] => () :  Adjoint, Controlled)
{
    let (evolutionSet, generatorSystem) = evolutionGenerator
    let (nTerms, generatorSystemFunction) = generatorSystem
    let trotterForm = (nTerms, ApplyEvolutionImpl(evolutionGenerator, _, _, _))
    return (DecomposeIntoTimeStepsCA(trotterForm,trotterOrder))(trotterStepSize, _)
}


//For adiabatic state preparation
operation Schedule(trotterSlice : ((Double, Double, Qubit[]) => ()), timeSteps : Int, qubits: Qubit[]) : (){
    Body{
        let timeStep = Float(1) / Float(timeSteps)
        for(idxStep in 0..timeSteps - 1){
            let time = timeStep * Float(idxStep) 
            trotterSlice(time, timeStep, qubits)
        }
    }
}

//For LCU

}


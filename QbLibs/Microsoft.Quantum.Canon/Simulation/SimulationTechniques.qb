namespace Microsoft.Quantum.Canon {
    
    /// Convert the description of dynamics in the Hamiltonian to a form compatible with the Trotterization library
    operation _TrotterStep(evolutionGenerator: EvolutionGenerator, idx : Int, stepsize: Double, qubits: Qubit[]) : () {
        Body{
            let (evolutionSet, generatorSystem) = evolutionGenerator
            let (nTerms, generatorSystemFunction) = generatorSystem
            let (generatorIndex, coefficient) = generatorSystemFunction(idx)
            (evolutionSet(generatorIndex))(coefficient * stepsize, qubits)
        }
        Adjoint auto
        Controlled auto
        Controlled Adjoint auto
    }
    function TrotterStep(evolutionGenerator: EvolutionGenerator, trotterOrder: Int, trotterStepSize: Double) : (Qubit[] => () :  Adjoint, Controlled)
    {
        let (evolutionSet, generatorSystem) = evolutionGenerator
        let (nTerms, generatorSystemFunction) = generatorSystem
        let trotterForm = (nTerms, _TrotterStep(evolutionGenerator, _, _, _))
        return (DecomposeIntoTimeStepsCA(trotterForm,trotterOrder))(trotterStepSize, _)
    }


    //Applies a sequence of TrotterStep according to a schedule, e.g. for adiabatic state preparation
    operation ApplyEvolutionSchedule(evolutionSchedule : EvolutionSchedule, nTimeSteps : Int, qubits: Qubit[]) : (){
        Body{
            let timeStep = Float(1) / Float(nTimeSteps)
            for(idxStep in 0..nTimeSteps - 1){
                let time = timeStep * Float(idxStep) 
                evolutionSchedule(time, timeStep, qubits)
            }
        }
        Adjoint auto
        Controlled auto
        Controlled Adjoint auto
    }
   


    //State prep + Adiabatic state prep + energy estimation
    operation AdiabaticStateEnergyPrepare(bitsPrecision : Int,
                                          timeSteps : Int, 
                                          statePrepUnitary: (Qubit[] => ()),
                                          evoSchedule : EvolutionSchedule, 
                                          qpeUnitary: (Qubit[] => () :  Adjoint, Controlled),
                                          qubits: Qubit[]) : Double
    {
        Body {
            statePrepUnitary(qubits)
            ApplyEvolutionSchedule(evoSchedule, timeSteps, qubits)
            let phaseEst = RobustPhaseEstimation(bitsPrecision, OracleToDiscrete(qpeUnitary), qubits)
            return phaseEst

        }
    }

    //Qubits + State prep + Adiabatic state prep + energy estimation
    operation AdiabaticStateEnergyEstimate(nQubits : Int, 
                                           bitsPrecision : Int,
                                           timeSteps : Int, 
                                           statePrepUnitary: (Qubit[] => () ),
                                           evoSchedule : EvolutionSchedule, 
                                           qpeUnitary: (Qubit[] => () :  Adjoint, Controlled)) : Double
    {
        Body{
            mutable phaseEst = ToDouble(0)
            using(qubits = Qubit[nQubits]){
                ResetAll(qubits)
                set phaseEst = AdiabaticStateEnergyPrepare(bitsPrecision,timeSteps,statePrepUnitary,evoSchedule,qpeUnitary,qubits)
                ResetAll(qubits)
            }
            return phaseEst

        }
    }

    //Qubits + State Prep +  quantum phase estimation
    operation EstimateEnergy(nQubits : Int, 
                            bitsPrecision : Int,
                            statePrepUnitary: (Qubit[] => () ), 
                            qpeUnitary: (Qubit[] => () :  Adjoint, Controlled)) : Double
    {
         Body{
            let phaseEst = AdiabaticStateEnergyEstimate(nQubits,bitsPrecision, 0, statePrepUnitary, IdentityEvolutionSchedule(), qpeUnitary)
            return phaseEst
        }   
    }
//For LCU

}


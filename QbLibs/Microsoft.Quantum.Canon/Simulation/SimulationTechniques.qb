namespace Microsoft.Quantum.Canon {
    
    
    operation _TrotterStep(evolutionGenerator: EvolutionGenerator, idx : Int, stepsize: Double, qubits: Qubit[]) : () {
        Body{
            let (evolutionSet, generatorSystem) = evolutionGenerator
            let (nTerms, generatorSystemFunction) = generatorSystem
            let (generatorIndex, coefficient) = generatorSystemFunction(idx)
            (evolutionSet(generatorIndex))(coefficient * stepsize, qubits)
        }
        Adjoint auto
        Controlled auto
        Controlled Adjoint auto
    }

    /// summary:
    ///     Convert the description of dynamics in the Hamiltonian to a form compatible with the Trotterization library.
    function TrotterStep(evolutionGenerator: EvolutionGenerator, trotterOrder: Int, trotterStepSize: Double) : (Qubit[] => () :  Adjoint, Controlled)
    {
        let (evolutionSet, generatorSystem) = evolutionGenerator
        let (nTerms, generatorSystemFunction) = generatorSystem
        let trotterForm = (nTerms, _TrotterStep(evolutionGenerator, _, _, _))
        return (DecomposeIntoTimeStepsCA(trotterForm,trotterOrder))(trotterStepSize, _)
    }


    /// summary:
    ///     Applies a sequence of TrotterStep according to a schedule, e.g. for adiabatic state preparation.
    operation ApplyEvolutionSchedule(evolutionSchedule : EvolutionSchedule, nTimeSteps : Int, qubits: Qubit[]) : (){
        Body{
            let timeStep = Float(1) / Float(nTimeSteps)
            for(idxStep in 0..nTimeSteps - 1){
                let time = timeStep * Float(idxStep) 
                evolutionSchedule(time, timeStep, qubits)
            }
        }
        Adjoint auto
        Controlled auto
        Controlled Adjoint auto
    }

    /// summary:
    ///     Performs state preparation, and adiabatic state preparation, and phase est.
    operation AdiabaticStateEnergyPrepare(timeSteps : Int,
                                          statePrepUnitary: (Qubit[] => ()),
                                          evoSchedule : EvolutionSchedule,
                                          qpeUnitary: (Qubit[] => () :  Adjoint, Controlled),
                                          phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double),
                                          qubits: Qubit[]) : Double
    {
        Body {
            statePrepUnitary(qubits)
            ApplyEvolutionSchedule(evoSchedule, timeSteps, qubits)
            let phaseEst = phaseEstAlgorithm(OracleToDiscrete(qpeUnitary), qubits)
            return phaseEst

        }
    }

    //Qubits + State prep + Adiabatic state prep + energy estimation
    operation AdiabaticStateEnergyEstimate(nQubits : Int, 
                                           timeSteps : Int, 
                                           statePrepUnitary: (Qubit[] => () ),
                                           evoSchedule : EvolutionSchedule, 
                                           qpeUnitary: (Qubit[] => () :  Adjoint, Controlled),
                                           phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double)) : Double
    {
        Body {
            mutable phaseEst = ToDouble(0)
            using(qubits = Qubit[nQubits]){
                ResetAll(qubits)
                set phaseEst = AdiabaticStateEnergyPrepare(
                    timeSteps,
                    statePrepUnitary,
                    evoSchedule,
                    qpeUnitary,
                    phaseEstAlgorithm,
                    qubits)
                ResetAll(qubits)
            }
            return phaseEst

        }
    }

    //Qubits + State Prep +  quantum phase estimation
    operation EstimateEnergy(nQubits : Int,
                             statePrepUnitary: (Qubit[] => () ),
                             qpeUnitary: (Qubit[] => () :  Adjoint, Controlled),
                             phaseEstAlgorithm : ((DiscreteOracle, Qubit[]) => Double)) : Double
    {
         Body {
            let phaseEst = AdiabaticStateEnergyEstimate(nQubits, 0, statePrepUnitary, IdentityEvolutionSchedule(), qpeUnitary, phaseEstAlgorithm)
            return phaseEst
        }
    }
//For LCU

}


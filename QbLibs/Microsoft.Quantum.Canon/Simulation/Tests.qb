namespace Microsoft.Quantum.Canon {
    open Microsoft.Quantum.Primitive
    /// This contains unit tests for the Simulation library

    // Due to UDTs not propagating in multifiles properly, we must instantiate an EvolutionSet.
    // FIXME remove when Bug 781 is resolved
    operation BUG781WorkAroundA(idx : GeneratorIndex, delta : Double, qubits: Qubit[]) : ()    {
        Body{}
        Adjoint auto
        Controlled auto
        Controlled Adjoint auto
    }
    function BUG781WorkAroundB(idx : GeneratorIndex) : EvolutionUnitary    {
        return EvolutionUnitary(BUG781WorkAroundA(idx, _, _))
    }
    function BUG781WorkAroundC() : EvolutionSet    {
        return EvolutionSet(BUG781WorkAroundB)
    }

    // Using the Hamiltonian representation library
    function HamiltonianGeneratorTerm(idxHamiltonian : Int) : GeneratorTerm
    {
        // Pass empty double as Pauli set not indexed by continuous parameters
        let e = new Double[0]
        let coefficient = 0.5
        let generatorIndex = GeneratorIndex(([1;2;3],e), [1;2;3])
        return GeneratorTerm(generatorIndex, coefficient)
    }

    function HamiltonianGeneratorSystem() : GeneratorSystem
    {
        let nTerms = 5
        return GeneratorSystem(nTerms, HamiltonianGeneratorTerm)
    }

    function HamiltonianEvolutionGenerator() : EvolutionGenerator
    {
        let generatorSystem = HamiltonianGeneratorSystem()
        let evolutionSet = PauliEvolutionSet()
        return EvolutionGenerator(evolutionSet, generatorSystem)

    }

    /// Test of Trotterization and EvolutionSetPauli

    operation slice(qubits : Qubit[], step: Double) : (){
        Body{
            //let qubit = QubitSlice([0;1],qubits)
            Exp([Ipauli], step, [qubits[0]])
        }
        Adjoint auto
    }

    function SinSquared(theta : Double) : Double {
        let amp = Sin(theta)
        let prob = amp * amp
        return prob
    }

    operation ExpKnownStateTestHelper(pauli : Pauli, angle : Double, expected : (Complex, Complex), preparation : (Qubit => ())) : () {
    
        Body {
            using (register = Qubit[1]) {
                let qubit = register[0]

                preparation(qubit)
                Exp([pauli], angle, register)
                AssertQubitState(expected, qubit, 1e-5)
                Reset(qubit)
            }
        }

    }

    /// summary:
    ///     Applies Exp(…) to states for which its action is known a priori
    ///     and asserts that the correct result is obtained.
    operation ExpKnownStateTest() : () {
        Body {
            // exp{+i π Z / 3} |+〉
            ExpKnownStateTestHelper(Zpauli, Pi() / 3.0, (Complex(0.35355339059327384, 0.6123724356957946), Complex(0.35355339059327384, -0.6123724356957946)), H)
        }
    }

    operation EvolutionSetPauliTest() : () {
        Body {

            let step = 0.12483
            let e = [1.0]

            let ops = [(([1],e),[0]); (([2],e),[0]); (([0;3],e),[0;1]); (([1;3],e),[0;1]); (([2;3],e),[1;0]); (([1],[-2.0]),[1]);  (([2;3;1;1],e),[3;6;4;1])]
            let opsTarget = [[Xpauli]; [Ypauli]; [Ipauli;Zpauli]; [Xpauli;Zpauli]; [Zpauli;Ypauli]; [Ipauli;Xpauli]; [Ipauli;Xpauli;Ipauli;Ypauli;Xpauli;Ipauli;Zpauli]]

            for(idxOp in 0..6){
                let op = ops[idxOp]
                let opTarget = opsTarget[idxOp]
                let (idxGen,idxQubits) = op
                let (idxPaulis, idxDoubles) = idxGen

                let multiplier = idxDoubles[0]
                 
                let generatorIndex = GeneratorIndex(idxGen,idxQubits)
                let nQubits = Length(opTarget)
                
                
                let opA = (PauliEvolutionFunction(generatorIndex))(step, _)
                let opB = Exp(opTarget, step, _)
                AssertOperationsEqualReferenced(opA, opB, nQubits) 

                //using(qubits2 = Qubit[2]){
                    //ResetAll(qubits2)
                //    opB(qubits2)
                 //   opA(qubits2)
                    //AssertProb([Zpauli], [qubits2[1]], Zero, 1.0, "Fail [Ipauli;Xpauli] [0;1]",  1e-10)
                 //   ResetAll(qubits2)
                //}
                
                //let opC = Exp([Ipauli; Ipauli], 0.9 * step, _)
                ///slice(_,step)
                //let opD = Exp([Ipauli; Ipauli], step, _)
                //AssertOperationsEqualReferenced(opC, opD, 2) 
            }
            using(qubits = Qubit[7]){
                ResetAll(qubits)

                let amp = Sin(step)
                let prob = amp * amp

             

                //It appears that single-qubit paulis only have have double the coefficient

                Exp([Xpauli], 0.5 * step, qubits[0..0])
                Exp([Xpauli], -0.5 * step, [qubits[0]])
                AssertProb([Zpauli], [qubits[0]], Zero, 1.0, "Fail [Xpauli] [0]",  1e-10)
                
                ResetAll(qubits)

                Exp([Xpauli; Ipauli], 1.0 * step, qubits[0..1])
                Exp([Xpauli], -step, [qubits[0]])
                AssertProb([Zpauli], [qubits[0]], Zero, 1.0, "Fail [Xpauli;Ipauli] [0;1]",  1e-10)

                ResetAll(qubits)
				Exp([Xpauli; Xpauli], 1.0 * step, qubits[0..1])              
                AssertProb([Zpauli], [qubits[0]], One, SinSquared(step), "Fail [Xpauli;Xpauli] [0;1]",  1e-10)
				ResetAll(qubits)

                H(qubits[0])
                Exp([Zpauli; Zpauli], 1.0 * step, qubits[0..1])  
                H(qubits[0])
                AssertProb([Zpauli], [qubits[0]], One, SinSquared(step), "Fail [Zpauli;Zpauli] [0;1]",  1e-10)
                ResetAll(qubits)
	
                H(qubits[0])
                Exp([Zpauli; Zpauli; Zpauli], 1.0 * step, qubits[0..2])  
                H(qubits[0])
                AssertProb([Zpauli], [qubits[0]], One, SinSquared(step), "Fail [Zpauli;Zpauli;Zpauli] [0;1;2]",  1e-10)
                ResetAll(qubits)

                H(qubits[0])
                Exp([Zpauli; Zpauli; Zpauli; Xpauli], 1.0 * step, qubits[0..3])  
                H(qubits[0])
                AssertProb([Zpauli], [qubits[0]], One, SinSquared( step), "Fail [Zpauli;Zpauli;Zpauli;Xpauli] [0;1;2]",  1e-10)
                ResetAll(qubits)
                                
                H(qubits[0])
                Exp([Zpauli; Xpauli;Zpauli], 1.0 * step, qubits[0..2])  
                H(qubits[0])
                AssertProb([Zpauli], [qubits[0]], One, SinSquared(1.0 * step), "Fail [Zpauli;Xpauli;Zpauli] [0;1;2]",  1e-10)
                ResetAll(qubits)

                H(qubits[0])
                Exp([Zpauli], 1.0 * step, qubits[0..0])  
                H(qubits[0])
                AssertProb([Zpauli], [qubits[0]], One, SinSquared(1.0 * step), "Fail [Zpauli] [0]",  1e-10)
                ResetAll(qubits)

                H(qubits[1])
                Exp([Zpauli], 1.0 * step, qubits[1..1])  
                H(qubits[1])
                AssertProb([Zpauli], [qubits[1]], One, SinSquared(1.0 * step), "Fail [Zpauli] [1]",  1e-10)
                ResetAll(qubits)                                
                                
                H(qubits[0])
                Exp([Zpauli; Xpauli;Xpauli], 1.0 * step, qubits[0..2])  
                H(qubits[0])
                AssertProb([Zpauli], [qubits[0]], One, SinSquared(1.0 * step), "Fail [Zpauli;Xpauli;Xpauli] [0;1;2]",  1e-10)
                ResetAll(qubits)

                Exp([Xpauli; Zpauli;Zpauli], 1.0 * step, qubits[0..2])  
                AssertProb([Zpauli], [qubits[0]], One, SinSquared(1.0 * step), "Fail [Xpauli;Zpauli;Zpauli] [0;1;2]",  1e-10)
                ResetAll(qubits)
                
                Exp([Ipauli; Xpauli], 1.0 * step, qubits[0..1])
                Exp([Xpauli], -step, [qubits[1]])
                AssertProb([Zpauli], [qubits[1]], Zero, 1.0, "Fail [Ipauli; Xpauli] [0;1]",  1e-10)

                ResetAll(qubits)

                //Exp([Ipauli; Ipauli; Xpauli], 2.0 * step, qubits[0..2])
                Exp([Xpauli], 1.0 * step, qubits[2..2])
                AssertProb([Zpauli], [qubits[2]], One, SinSquared(1.0*step), "Fail [Xpauli] [2]",  1e-10)

                ResetAll(qubits)

                Exp([Xpauli], 1.0 * step, qubits[0..0])
                AssertProb([Zpauli], [qubits[0]], One, SinSquared(1.0*step), "Fail [Xpauli] [0]",  1e-10)

                ResetAll(qubits)

                Exp([Xpauli;Ipauli], 1.0 * step, qubits[0..1])
                AssertProb([Zpauli], [qubits[0]], One, SinSquared(step), "Fail [Xpauli;Ipauli] [0;1]",  1e-10)

                ResetAll(qubits)

                Exp([Ipauli;Xpauli], 1.0 * step, qubits[0..1])
                AssertProb([Zpauli], [qubits[1]], One, SinSquared(step), "Fail [Ipauli;Xpauli] [0;1]",  1e-10)

                ResetAll(qubits)

                Exp([Ypauli;Xpauli], 1.0 * step, QubitSlice([2;0],qubits))
                Exp([Xpauli;Ipauli;Ypauli], -1.0 * step, qubits[0..2])
                AssertProb([Zpauli], [qubits[1]], One, SinSquared(0.0*step), "Fail [Ipauli;Xpauli] [0;1]",  1e-10)

                ResetAll(qubits)

                Exp([Ypauli;Zpauli;Xpauli;Xpauli], 1.0 * step, QubitSlice([3;6;4;1],qubits))
                Exp([Ipauli;Xpauli;Ipauli;Ypauli;Xpauli;Ipauli;Zpauli], -1.0 * step, qubits[0..6])
                AssertProb([Zpauli], [qubits[0]], One, SinSquared(0.0*step), "Fail [Ipauli;Xpauli;Ipauli;Ypauli;Xpauli;Ipauli;Zpauli] [0]",  1e-10)
                AssertProb([Zpauli], [qubits[1]], One, SinSquared(0.0*step), "Fail [Ipauli;Xpauli;Ipauli;Ypauli;Xpauli;Ipauli;Zpauli] [1]",  1e-10)
                AssertProb([Zpauli], [qubits[2]], One, SinSquared(0.0*step), "Fail [Ipauli;Xpauli;Ipauli;Ypauli;Xpauli;Ipauli;Zpauli] [2]",  1e-10)
                AssertProb([Zpauli], [qubits[3]], One, SinSquared(0.0*step), "Fail [Ipauli;Xpauli;Ipauli;Ypauli;Xpauli;Ipauli;Zpauli] [3]",  1e-10)
                AssertProb([Zpauli], [qubits[4]], One, SinSquared(0.0*step), "Fail [Ipauli;Xpauli;Ipauli;Ypauli;Xpauli;Ipauli;Zpauli] [4]",  1e-10)
                AssertProb([Zpauli], [qubits[5]], One, SinSquared(0.0*step), "Fail [Ipauli;Xpauli;Ipauli;Ypauli;Xpauli;Ipauli;Zpauli] [5]",  1e-10)
                AssertProb([Zpauli], [qubits[6]], One, SinSquared(0.0*step), "Fail [Ipauli;Xpauli;Ipauli;Ypauli;Xpauli;Ipauli;Zpauli] [6]",  1e-10)
                ResetAll(qubits)

                H(qubits[0])
                Exp([Zpauli], ToDouble(1), [qubits[0]])
                Exp([Xpauli], ToDouble(1), [qubits[0]])
                AssertProb([Zpauli], [qubits[0]], One, 0.0865891, "Fail Sign H. Z . X",  1e-4)
                
                // This will not catch a sign error if both Assert ZZ and Exp ZZ have the wrong sign
                ResetAll(qubits)
                H(qubits[0])
                H(qubits[1])
                Exp([Zpauli;Zpauli], ToDouble(1), qubits[0..1])
                Exp([Xpauli], ToDouble(1), [qubits[0]])
                AssertProb([Zpauli;Zpauli], qubits[0..1], One, 0.0865891, "Fail Sign HH. ZZ . X",  1e-4)

                // This will not catch a sign error if both Assert ZZ and Exp XX have the wrong sign                
                ResetAll(qubits)
                Exp([Xpauli;Xpauli], ToDouble(1), qubits[0..1])
                Exp([Zpauli], ToDouble(1), [qubits[0]])
                H(qubits[0])
                H(qubits[1])
                AssertProb([Zpauli;Zpauli], qubits[0..1], One, 0.0865891, "Fail Sign  XX . Z . HH",  1e-4)
 
                // This should catch a sign error if both Assert Z and Exp ZZ have different signs
                ResetAll(qubits)
                Exp([Ypauli], ToDouble(1), [qubits[0]])
                Exp([Zpauli;Zpauli], ToDouble(1), qubits[0..1])
                Exp([Xpauli], ToDouble(1), [qubits[0]])
                AssertProb([Zpauli], qubits[0..0], One, 0.789324, "Fail Sign Y. ZZ . X",  1e-4)
                
                ResetAll(qubits)

            }
        }
    }

    operation ZZequalXX(qubits : Qubit[], gate: Int): (){
        Body{
            if(gate == 0){
                H(qubits[0])
                H(qubits[1])
                Exp([Zpauli;Zpauli], ToDouble(1), qubits[0..1])
                H(qubits[0])
                H(qubits[1])
            }
            else{
                Exp([Xpauli;Xpauli], ToDouble(1), qubits[0..1])
            }
        }
 
        Adjoint auto
    }
    operation ZZequalXXTest(): (){
        Body{
        AssertOperationsEqualReferenced(ZZequalXX(_,0),ZZequalXX(_,1), 2)
        }
    }
    //Converts a real value to a probability
    // FIXME: document this operation, rename to make it clear what it does,
    //        and move it to where it needs to be.
    operation ReadReal(value: Double) : () {
        Body{
            let angle = 2.0*ArcSin(Sqrt(value))
            using(q=Qubit[1]){
                Rx(angle,q[0])
                AssertProb([Zpauli], q, One, value, "Output value", 1e-10)

                Reset(q[0])
            }
        }
    }

}


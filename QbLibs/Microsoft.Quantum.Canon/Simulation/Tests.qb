namespace Microsoft.Quantum.Canon {
    open Microsoft.Quantum.Primitive
    /// This contains unit tests for the Simulation library

    // Due to UDTs not propagating in multifiles properly, we must instantiate an EvolutionSet.
    // FIXME remove when Bug 781 is resolved
    operation BUG781WorkAroundA(idx : GeneratorIndex, delta : Double, qubits: Qubit[]) : ()    {
        Body{}
        Adjoint auto
        Controlled auto
        Controlled Adjoint auto
    }
    function BUG781WorkAroundB(idx : GeneratorIndex) : EvolutionUnitary    {
        return EvolutionUnitary(BUG781WorkAroundA(idx, _, _))
    }
    function BUG781WorkAroundC() : EvolutionSet    {
        return EvolutionSet(BUG781WorkAroundB)
    }

    // Using the Hamiltonian representation library
    function HamiltonianGeneratorTerm(idxHamiltonian : Int) : GeneratorTerm
    {
        // Pass empty double as Pauli set not indexed by continuous parameters
        let e = new Double[0]
        let coefficient = 0.5
        let generatorIndex = GeneratorIndex(([1;2;3],e), [1;2;3])
        return GeneratorTerm(generatorIndex, coefficient)
    }

    function HamiltonianGeneratorSystem() : GeneratorSystem
    {
        let nTerms = 5
        return GeneratorSystem(nTerms, HamiltonianGeneratorTerm)
    }

    function HamiltonianEvolutionGenerator() : EvolutionGenerator
    {
        let generatorSystem = HamiltonianGeneratorSystem()
        let evolutionSet = PauliEvolutionSet()
        return EvolutionGenerator(evolutionSet, generatorSystem)

    }

    /// Test of Trotterization and EvolutionSetPauli

    operation slice(qubits : Qubit[], step: Double) : (){
        Body{
            //let qubit = QubitSlice([0;1],qubits)
            Exp([Ipauli], step, [qubits[0]])
        }
        Adjoint auto
    }

    function SinSquared(theta:Double) : Double{
        let amp = Sin(theta)
        let prob = amp * amp
        return prob
    }

    operation EvolutionSetPauliTest() : () {
        Body{

            let step = 0.12483
            let e = [1.0]

            let ops = [(([1],e),[0]); (([2],e),[0]); (([0;3],e),[0;1]); (([1;3],e),[0;1]); (([2;3],e),[1;0]); (([1],[-2.0]),[1]);  (([2;3;1;1],e),[3;6;4;1])]
            let opsTarget = [[Xpauli]; [Ypauli]; [Ipauli;Zpauli]; [Xpauli;Zpauli]; [Zpauli;Ypauli]; [Ipauli;Xpauli]; [Ipauli;Xpauli;Ipauli;Ypauli;Xpauli;Ipauli;Zpauli]]

            for(idxOp in 6..6){
                let op = ops[idxOp]
                let opTarget = opsTarget[idxOp]
                let (idxGen,idxQubits) = op
                let (idxPaulis, idxDoubles) = idxGen

                let multiplier = idxDoubles[0]
                 
                let generatorIndex = GeneratorIndex(idxGen,idxQubits)
                let nQubits = Length(opTarget)
                
                
                let opA = (PauliEvolutionFunction(generatorIndex))(step, _)
                let opB = Exp(opTarget, step, _)
                //AssertOperationsEqualReferenced(opA, opB, nQubits) 

                //using(qubits2 = Qubit[2]){
                    //ResetAll(qubits2)
                //    opB(qubits2)
                 //   opA(qubits2)
                    //AssertProb([Zpauli], [qubits2[1]], Zero, 1.0, "Fail [Ipauli;Xpauli] [0;1]",  1e-10)
                 //   ResetAll(qubits2)
                //}
                
                //let opC = Exp([Ipauli; Ipauli], 0.9 * step, _)
                ///slice(_,step)
                //let opD = Exp([Ipauli; Ipauli], step, _)
                //AssertOperationsEqualReferenced(opC, opD, 2) 
            }
            using(qubits = Qubit[7]){
                ResetAll(qubits)

                let amp = Sin(step)
                let prob = amp * amp

                //It appears that single-qubit paulis only have have double the coefficient

                Exp([Xpauli], 0.5 * step, qubits[0..0])
                Exp([Xpauli], -0.5 * step, [qubits[0]])
                AssertProb([Zpauli], [qubits[0]], Zero, 1.0, "Fail [Xpauli] [0]",  1e-10)
                
                ResetAll(qubits)

                Exp([Xpauli; Ipauli], 1.0 * step, qubits[0..1])
                Exp([Xpauli], -step, [qubits[0]])
                AssertProb([Zpauli], [qubits[0]], Zero, 1.0, "Fail [Xpauli;Ipauli] [0;1]",  1e-10)

                ResetAll(qubits)

                Exp([Ipauli; Xpauli], 1.0 * step, qubits[0..1])
                Exp([Xpauli], -step, [qubits[1]])
                AssertProb([Zpauli], [qubits[1]], Zero, 1.0, "Fail [Ipauli; Xpauli] [0;1]",  1e-10)

                ResetAll(qubits)

                //Exp([Ipauli; Ipauli; Xpauli], 2.0 * step, qubits[0..2])
                Exp([Xpauli], 1.0 * step, qubits[2..2])
                AssertProb([Zpauli], [qubits[2]], One, SinSquared(1.0*step), "Fail [Xpauli] [2]",  1e-10)

                ResetAll(qubits)

                Exp([Xpauli], 1.0 * step, qubits[0..0])
                AssertProb([Zpauli], [qubits[0]], One, SinSquared(1.0*step), "Fail [Xpauli] [0]",  1e-10)

                ResetAll(qubits)

                Exp([Xpauli;Ipauli], 1.0 * step, qubits[0..1])
                AssertProb([Zpauli], [qubits[0]], One, SinSquared(step), "Fail [Xpauli;Ipauli] [0;1]",  1e-10)

                ResetAll(qubits)

                Exp([Ipauli;Xpauli], 1.0 * step, qubits[0..1])
                AssertProb([Zpauli], [qubits[1]], One, SinSquared(step), "Fail [Ipauli;Xpauli] [0;1]",  1e-10)

                ResetAll(qubits)

                Exp([Ypauli;Xpauli], 1.0 * step, QubitSlice([2;0],qubits))
                Exp([Xpauli;Ipauli;Ypauli], -1.0 * step, qubits[0..2])
                AssertProb([Zpauli], [qubits[1]], One, SinSquared(0.0*step), "Fail [Ipauli;Xpauli] [0;1]",  1e-10)

                ResetAll(qubits)

                Exp([Ypauli;Zpauli;Xpauli;Xpauli], 1.0 * step, QubitSlice([3;6;4;1],qubits))
                Exp([Ipauli;Xpauli;Ipauli;Ypauli;Xpauli;Ipauli;Zpauli], -1.0 * step, qubits[0..6])
                AssertProb([Zpauli], [qubits[0]], One, SinSquared(0.0*step), "Fail [Ipauli;Xpauli;Ipauli;Ypauli;Xpauli;Ipauli;Zpauli] [0]",  1e-10)
                AssertProb([Zpauli], [qubits[1]], One, SinSquared(0.0*step), "Fail [Ipauli;Xpauli;Ipauli;Ypauli;Xpauli;Ipauli;Zpauli] [1]",  1e-10)
                AssertProb([Zpauli], [qubits[2]], One, SinSquared(0.0*step), "Fail [Ipauli;Xpauli;Ipauli;Ypauli;Xpauli;Ipauli;Zpauli] [2]",  1e-10)
                AssertProb([Zpauli], [qubits[3]], One, SinSquared(0.0*step), "Fail [Ipauli;Xpauli;Ipauli;Ypauli;Xpauli;Ipauli;Zpauli] [3]",  1e-10)
                AssertProb([Zpauli], [qubits[4]], One, SinSquared(0.0*step), "Fail [Ipauli;Xpauli;Ipauli;Ypauli;Xpauli;Ipauli;Zpauli] [4]",  1e-10)
                AssertProb([Zpauli], [qubits[5]], One, SinSquared(0.0*step), "Fail [Ipauli;Xpauli;Ipauli;Ypauli;Xpauli;Ipauli;Zpauli] [5]",  1e-10)
                AssertProb([Zpauli], [qubits[6]], One, SinSquared(0.0*step), "Fail [Ipauli;Xpauli;Ipauli;Ypauli;Xpauli;Ipauli;Zpauli] [6]",  1e-10)
                ResetAll(qubits)

            }
        }
    }

    //Converts a real value to a probability
    // FIXME: document this operation, rename to make it clear what it does,
    //        and move it to where it needs to be.
    operation ReadReal(value: Double) : () {
        Body{
            let angle = 2.0*ArcSin(Sqrt(value))
            using(q=Qubit[1]){
                Rx(angle,q[0])
                AssertProb([Zpauli], q, One, value, "Output value", 1e-10)

                Reset(q[0])
            }
        }
    }

}


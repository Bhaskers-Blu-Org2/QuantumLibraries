// namespace Microsoft.Quantum.Canon

///     `(params, time, qubits) => Rz(time, qubits)`, with the `params` field
///     being ignored, while another gate set might use `params` to indicate
///     application of gates such as exp(-i [X cos φ + Y sin φ] t).

/// summary:
///     Represents a single term in the expansion of a dynamical generator
///     such as a Hamiltonian. The first element of each term is an integer
///     label into a `GateSet`, while the second element is an array of
///     indexes on which the given term acts, and the final argument is the set
///     of real numbers parameterizing the application of the corresponding
///     operation.
///
///     From the view of a GeneratorTerm, a Hamiltonian is an operation of
///     the form (Double, Qubit[]) => () that applies $e^{-i H t}$ to the
///     state of a given register.
// FIXME: unify this and the GateSet representation above with ContinousOracle.

/// Convention for GeneratorIndex = ((Int[],Double[]), Int[])
/// We index single Paulis as 0 for I, 1 for X, 2 for Y, 3 for Z.
/// We index Pauli strings with arrays of integers e.g. a = [3;1;1;2] for ZXXY.
/// We do not use the Double[] for indexing Pauli strings e.g. b = new Double[0]
/// We index the qubits that Pauli strings act on with arrays of integers e.g. q = [2,4,5,8] for Z_2 X_4 X_5, Y_8 
/// An example of a Pauli string GeneratorIndex is thus ((a,b), q)

/// Consider the Hamiltonian H = 0.1 XI + 0.2 IX + 0.3 ZY
/// Its GeneratorTerms are (([1],[]),[0]), 0.1),  (([1],[]),[1]), 0.2),  (([3],[2]),[0,1]), 0.3)
/// 

/// summary:
///     Represents a dynamical generator as a set of simulatable gates and
///     an expansion in terms of that basis.
///     Las parameter for number of terms
operation PauliEvolutionSetImpl(generatorIndex : GeneratorIndex, delta : Double, qubits: Qubit[]) : ()
{
    Body{
        let (generatorIndex, idxQubits) = GeneratorIndex
        let (idxPaulis, unused) = generatorIndex
        let pauliString = IntToPauli(idxPaulis)
        let op = Exp(pauliString, delta, _)
        RestrictToSubregisterCA(op, idxQubits)(qubits)
    }
    Adjoint auto
    Controlled auto
    Controlled Adjoint auto
}
function PauliEvolutionSet(generatorIndex : GeneratorIndex) : EvolutionUnitary
{
    return EvolutionUnitary(PauliEvolutionSetImpl(generatorIndex, _, _))
}


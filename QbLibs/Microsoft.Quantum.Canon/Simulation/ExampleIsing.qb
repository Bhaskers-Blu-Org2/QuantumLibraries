namespace Microsoft.Quantum.Canon {
    open Microsoft.Quantum.Primitive
    //Ising model without using any libraries

    // apply a ZZ-term 
    operation ApplyZZ( phi : Double, q1 : Qubit, q2 : Qubit ) : () { 
        Body {     
            CNOT(q1, q2)
            Rz(phi, q2)
            CNOT(q1, q2)
        }    
    }

    // stub for the floor function. FIXME: remove if Floor is supported in Solid standard lib.
    function floor (a : Double) : Int {}

    /// <summary> Simulate the time evolution of an Ising model under a transverse field </summary>
    /// <param name = "nSites"> Number of spins of the Ising model </param>
    /// <param name = "time"> Overall time of the simulation </param>
    /// <param name = "dt"> The length of a timestep of the simulation </param>
    operation Ising (nSites : Int, time : Double, dt : Double) : Result[] { 
        Body {         
            mutable result = new Result[nSites]
            // allocate the qubits for the Ising chain
            using (qs = Qubit[nSites]) { 
                // start from a ground state aligned in the x direction by applying a Hadamard gate to all qubits
                for (i in 0..Length(qs)-1) { 
                    H(qs[i])
                }
                
                // choose the runtime and Trotter time step
                let nsteps = floor(time / dt)

                // choose the couplings
                let hx = 1.0   // transverse field
                let hz = 0.5 // longitiduinal field
                let J = 1.0   // Ising coupling

                // evolve using a second order Trotter decomposition
                for (idxIter in 0..nsteps/2) {
                    // improve locality of qubit references for simulation by applying all terms locally
                    // before moving to the next qubit.
                    for (idxSite in 0..nSites) {
                        Rx(hx * dt, qs[idxSite])
                        Rz(hz * dt, qs[idxSite])
                        if (idxSite + 1 < nSites) {
                            ApplyZZ(J * dt, qs[idxSite], qs[idxSite + 1])
                        }
                    }
                    for (idxSite in (nSites-1)..-1..0) {                 
                        if (idxSite + 1 < nSites) {
                            ApplyZZ(J * dt, qs[idxSite], qs[idxSite + 1])
                        }
                        Rz(hz * dt, qs[idxSite])
                        Rx(hx * dt, qs[idxSite])
                    }
                }
                
                for (idx in 0..Length(qs)-1) { 
                    set result[idx] = M(qs[idx])
                }        
            }
            return result
        }
    }

    operation TestIsing () : Result[] { 
        Body { 
            return Ising(10, 1.0, 100.0)                
        }
    }




    // Ising model using the Trotterization library directly
    // Hamiltonian = -(J0 Z0 Z1 + J1 Z1 Z2 + ...) - hz (Z0 + Z1 + ...) - hx (X0 + X1 + ...)
    // idxHamiltonian is in [0, nSites - 1]
    operation IsingTrotterUnitariesImpl(nSites : Int, hx : Double, hz: Double, jC: Double, idxHamiltonian: Int, stepSize : Double, qubits : Qubit[]) : ()
    {
        Body{
            // when idxHamiltonian is in [0, nSites - 1], apply transverse field "hx"
            // when idxHamiltonian is in [nSites, 2 * nSites - 1], apply and longitudinal field "hz"
            // when idxHamiltonian is in [2 * nSites, 3 * nSites - 2], apply Ising coupling "jC"
            //TODO Need to separate Rx out as it does not commute
            if(idxHamiltonian <= nSites - 1){
                Exp([Xpauli], -1.0 * hx * stepSize, [qubits[idxHamiltonian]])
                //Rx(hx * stepSize, qubits[idxHamiltonian])
            }
            elif(idxHamiltonian <= 2 * nSites - 1){
                Exp([Zpauli], -1.0 * hz * stepSize, [qubits[idxHamiltonian % nSites]])
                //Rz(hz * stepSize, qubits[idxHamiltonian % nSites])
            }
            else{
                Exp([Zpauli; Zpauli],  -1.0 * jC * stepSize, qubits[(idxHamiltonian % nSites)..(idxHamiltonian + 1) % nSites])
            }
        }
        Adjoint auto
        Controlled auto
        Controlled Adjoint auto
    }

    function IsingTrotterUnitaries(nSites : Int, hx : Double, hz: Double, jC: Double) : (Int, ((Int, Double, Qubit[]) => () : Adjoint, Controlled))
    {
        let nTerms = 3 * nSites - 1
        return (nTerms, IsingTrotterUnitariesImpl(nSites, hx, hz, jC, _, _, _))
    }

    operation IsingTrotterStepA(nSites : Int, hx : Double, hz: Double, jC: Double, trotterOrder: Int, trotterStepSize: Double) : (Qubit[] => ())
    {
        Body{
            let op = IsingTrotterUnitaries(nSites, hx, hz, jC)
            return (DecomposeIntoTimeStepsCA(op,trotterOrder))(trotterStepSize, _)
        }
    }


    // Ising model using the Hamiltonian representation library
    // More general function for coupling terms
    // idxHamiltonian is in [0, 3 * nSites - 2]
    // jC is a function mapping (number of sites, index of site) to the coupling strength
    function _jCDomainWall(nSites: Int, idxSite: Int) : Double
    {
        let middle = nSites / 2
        if(idxSite == middle -1 ){
            return -1.0
        }
        else{
            return 1.0
        }
    }
    function _jCUniform(nSites: Int, idxSite: Int): Double
    {
        return 1.0
    }

    function IsingGeneratorTerm(nSites : Int, hx : Double, hz: Double, jC: ((Int, Int) -> Double), idxHamiltonian : Int) : GeneratorTerm
    {
        // when idxHamiltonian is in [0, nSites - 1], apply transverse field "hx"
        // when idxHamiltonian is in [nSites, 2 * nSites - 1], apply longitudinal field "hz"
        // when idxHamiltonian is in [2 * nSites, 3 * nSites - 2], apply Ising coupling "jC"
            let e = new Double[0]
            mutable idxPauliString = new Int[0]
            mutable idxQubits = new Int[0]
            mutable coeff = Float(0)

            if(idxHamiltonian <= nSites - 1){
                set idxPauliString = [1]
                set idxQubits = [idxHamiltonian]
                set coeff = hx
            }
            elif(idxHamiltonian <= 2 * nSites - 1){
                set idxPauliString = [3]
                set idxQubits = [idxHamiltonian % nSites]
                set coeff = hz
            }
            else{
                set idxPauliString = [3; 3]
                set idxQubits = [idxHamiltonian % nSites; (idxHamiltonian +1) % nSites]
                set coeff = jC(nSites, idxHamiltonian % nSites)
            }

            let generatorIndex = GeneratorIndex((idxPauliString,e),idxQubits)
            let generatorTerm = GeneratorTerm(generatorIndex, coeff)
            return generatorTerm
    }

    function  IsingGeneratorSystem(nSites : Int, hx : Double, hz: Double, jC: ((Int, Int) -> Double)) : GeneratorSystem 
    {
        let nTerms = 3 * nSites - 1
        return GeneratorSystem(nTerms, IsingGeneratorTerm(nSites, hx, hz, jC(_,_), _))
    }

    function IsingEvolutionGenerator(nSites : Int, hx : Double, hz: Double, jC: ((Int, Int) -> Double)) : EvolutionGenerator
    {
        let generatorSystem = IsingGeneratorSystem(nSites, hx, hz, jC(_,_))
        let evolutionSet = PauliEvolutionSet()
        return EvolutionGenerator(evolutionSet, generatorSystem)
    }


    function IsingTrotterStepB(nSites : Int, hx : Double, hz: Double, jC: ((Int, Int) -> Double), trotterOrder: Int, trotterStepSize: Double): (Qubit[] => () : Adjoint, Controlled)
    {
        let evolutionGenerator = IsingEvolutionGenerator(nSites, hx, hz, jC(_,_))
        return TrotterStep(evolutionGenerator, trotterOrder, trotterStepSize)
    }

/// Tests
/// Adiabatic state preparation followed by phase estimation and measurement of sites
    // time goes from 0 to 1.0
    // jC goes from 0.0 to 0.5

    
    function _jCSchedule(nSites: Int, schedule : Double, idxSite: Int, jC: ((Int, Int) -> Double)) : Double
    {
        return schedule * jC(nSites, idxSite)
    }

    operation _IsingSchedule(nSites : Int, jC: ((Int, Int) -> Double), trotterOrder: Int, schedule : Double, stepSize: Double, qubits: Qubit[]) : ()
    {
        Body{
            let hx = 1.0 - schedule
            let hz = ToDouble(0)
            let jcSchedule = _jCSchedule(_,schedule,_,jC)
           (IsingTrotterStepB(nSites, hx, hz, jcSchedule, trotterOrder, stepSize))(qubits)
        }
        Adjoint auto
        Controlled auto
        Controlled Adjoint auto
    }
    operation _IsingStatePrep(qubits : Qubit[]) : (){
        Body{
            ApplyToEachAC(H, qubits)
        }
    }
    operation IsingEstimate(nSites : Int, jC: ((Int, Int) -> Double), bitsPrecision : Int, trotterOrder : Int, timeSteps : Int, qpeStepSize:Double) : (Double, Result[]){
        Body{
            let statePrepUnitary = _IsingStatePrep
            let evolutionTimeDependent = EvolutionTimeDependent(_IsingSchedule(nSites, jC, trotterOrder, _, _, _))
            let qpeUnitary = _IsingSchedule(nSites, jC, trotterOrder, 1.0, qpeStepSize, _)

            mutable phaseEst = 0.1
            mutable results = new Result[nSites]
            using(qubits = Qubit[nSites]){
                set phaseEst = AdiabaticStateEnergyPrepare(bitsPrecision, timeSteps, statePrepUnitary, evolutionTimeDependent, qpeUnitary, qubits) / qpeStepSize
                set results = MultiM(qubits)
            }
            return (phaseEst, results)
           
        }
    }
    operation IsingTest() : (){
        Body{
            let nSites = 4
            let hx = 0.2
            let hz = 0.1
            let jC = _jCUniform
            let jCconstant = jC(nSites,0)
            let trotterOrder = 1
            let trotterStepSize = 0.1
            let opA = IsingTrotterStepA(nSites, hx, hz, jCconstant, trotterOrder, trotterStepSize)
            let opB = IsingTrotterStepB(nSites, hx, hz, jC, trotterOrder, trotterStepSize)
            AssertOperationsEqualReferenced(opA, opB, nSites)
        }
    }
    operation IsingEnergyTest() : (){
        Body{
            let nSites = 4
            let jC = _jCUniform
            let trotterOrder = 1
            let trotterStepSize = 0.1
            let bitsPrecision = 6
            let timeSteps = 2
            let qpeStepSize = 0.1

            let (phaseEst, results) = IsingEstimate(nSites, jC, bitsPrecision, trotterOrder, timeSteps, qpeStepSize)

            ReadReal(phaseEst)
        }
    }

/// D-wave 2D all to all
    // Ising model using the Hamiltonian representation library
    // idxHamiltonian is in [0, 3 * nSites - 2]
    function Ising2DGeneratorTerm(nSitesLengths : Int[], hx : Double, jCGlobal : Double, jCArr: (Int[],Int[], Double)[], idxHamiltonian : Int) : GeneratorTerm
    {
        let nSitesX = nSitesLengths[0]
        let nSitesY = nSitesLengths[1]
        let nSites = nSitesX * nSitesY
        let nCouplings = Length(jCArr)
        // when idxHamiltonian is in [0, nSites - 1], apply transverse field "hx"
        // when idxHamiltonian is in [nSites, nSites + nCouplings - 1], apply Ising couplings jCArr
            let e = new Double[0]
            mutable idxPauliString = new Int[0]
            mutable idxQubits = new Int[0]
            mutable coeff = Float(0)

            if(idxHamiltonian <= nSites - 1){
                set idxPauliString = [1]
                set idxQubits = [idxHamiltonian]
                set coeff = hx
            }
            elif(idxHamiltonian <= nSites + nCouplings - 1){
                let (xyA, xyB, coeffTemp) = jCArr[idxHamiltonian % nSites]
                let idxSiteA = xyA[0] + xyA[1] * nSitesX
                let idxSiteB = xyB[0] + xyB[1] * nSitesX
                set idxPauliString = [3; 3]
                set idxQubits = [idxSiteA; idxSiteB]
                set coeff = jCGlobal * coeffTemp
            }

            let generatorIndex = GeneratorIndex((idxPauliString,e),idxQubits)
            let generatorTerm = GeneratorTerm(generatorIndex, coeff)
            return generatorTerm
    }

    function  Ising2DGeneratorSystem(nSitesLengths : Int[], hx : Double, jCGlobal : Double, jCArr: (Int[],Int[], Double)[]) : GeneratorSystem 
    {
        let nSitesX = nSitesLengths[0]
        let nSitesY = nSitesLengths[1]
        let nSites = nSitesX * nSitesY
        let nCouplings = Length(jCArr)
        let nTerms = nSites + nCouplings
        return GeneratorSystem(nTerms, Ising2DGeneratorTerm(nSitesLengths, hx, jCGlobal, jCArr, _))
    }

    function Ising2DEvolutionGenerator(nSitesLengths : Int[], hx : Double, jcGlobal : Double, jCArr: (Int[],Int[], Double)[]) : EvolutionGenerator
    {
        let generatorSystem = Ising2DGeneratorSystem(nSitesLengths, hx, jcGlobal, jCArr)
        let evolutionSet = PauliEvolutionSet()
        return EvolutionGenerator(evolutionSet, generatorSystem)
    }


    function Ising2DTrotterStepB(nSitesLengths : Int[], hx : Double, jCGlobal : Double, jCArr: (Int[],Int[], Double)[], trotterOrder: Int, trotterStepSize: Double): (Qubit[] => () : Adjoint, Controlled)
    {
        let evolutionGenerator = Ising2DEvolutionGenerator(nSitesLengths, hx, jCGlobal, jCArr)
        return TrotterStep(evolutionGenerator, trotterOrder, trotterStepSize)
    }

    /// Test random couplings in +- 1 and do adiabatic ramp
    operation _Ising2DSchedule(nSitesLengths : Int[], jCArr: (Int[],Int[], Double)[], trotterOrder: Int, time : Double, trotterStepSize: Double, qubits: Qubit[]) : ()
    {
        Body{
            let hx = 1.0 - time
            let jCGlobal = 0.5 * time
           (Ising2DTrotterStepB(nSitesLengths, hx, jCGlobal, jCArr, trotterOrder, trotterStepSize))(qubits)
        }
        Adjoint auto
        Controlled auto
        Controlled Adjoint auto
    }
    operation _Ising2DStatePrep(qubits : Qubit[]) : (){
        Body{
            ApplyToEachAC(H, qubits)
        }
    }
    operation Ising2DEstimate(nSitesLengths : Int[], jCArr: (Int[],Int[], Double)[], bitsPrecision : Int, trotterOrder : Int, timeSteps : Int, qpeStepSize:Double) : (Double, Result[]){
        Body{
            let statePrepUnitary = _Ising2DStatePrep
            let evolutionTimeDependent = EvolutionTimeDependent(_Ising2DSchedule(nSitesLengths, jCArr, trotterOrder, _, _, _))
            let qpeUnitary = _Ising2DSchedule(nSitesLengths, jCArr, trotterOrder, 1.0, qpeStepSize, _)
            let nSites = nSitesLengths[0] * nSitesLengths[1]
            mutable phaseEst = 0.1
            mutable results = new Result[nSites]
            using(qubits = Qubit[nSites]){
                set phaseEst = AdiabaticStateEnergyPrepare(bitsPrecision, timeSteps, statePrepUnitary, evolutionTimeDependent, qpeUnitary, qubits) / qpeStepSize
                set results = MultiM(qubits)
            }
            return (phaseEst, results)
           
        }
    }

    //Due to UDTs not propagating in multifiles properly, we must instantiate elements in an EvolutionSet.
    function BUG781WorkAroundB_0(idx : GeneratorIndex) : EvolutionUnitary    {
        return EvolutionUnitary(BUG781WorkAroundA(idx, _,_))
    }
}


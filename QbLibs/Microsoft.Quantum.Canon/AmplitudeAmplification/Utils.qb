namespace Microsoft.Quantum.Canon {
	open Microsoft.Quantum.Primitive

// Functions here may be commonly used in other libraries and could be made global.


	// Phase shift about |1...1><1...1|
	operation ReflectionAllOnes( phase: Double, qubits: Qubit[] ) : ()
	{
		Body{
			let nQubits = Length(qubits)
			let qubitFlag = qubits[0]
			let qubitsSystem = qubits[1..nQubits-1]

			(Controlled R1(phase, _))(qubitsSystem, qubitFlag)

		}

		Adjoint auto
		Controlled auto
		Controlled Adjoint auto
	}

	// Phase shift about |0...0><0...0|
	operation ReflectionAllZero( phase: Double, qubits: Qubit[] ) : ()
	{
		Body {

			WithCA(ApplyToEachAC(X, _), ReflectionAllOnes(phase, _), qubits)

		}

		Adjoint auto
		Controlled auto
		Controlled Adjoint auto
	}


    	/// <summary>
	/// Combines the oracles OracleStateDeterministic and OracleOblivious
	/// </summary>
    operation _OracleObliviousFromOracleStateDeterministic(oracleAncilla : OracleStateDeterministic, oracleSignal : OracleOblivious, qubitsAncilla: Qubit[], qubitsSystem: Qubit[]) : (){
		Body{
				oracleAncilla(qubitsAncilla)
				oracleSignal(qubitsAncilla, qubitsSystem)
		}
		Adjoint auto
		Controlled auto
		Adjoint Controlled auto
	}

	function OracleObliviousFromOracleStateDeterministic(oracleAncilla : OracleStateDeterministic, oracleSignal : OracleOblivious) : OracleOblivious{
		return OracleOblivious(_OracleObliviousFromOracleStateDeterministic(oracleAncilla, oracleSignal,_,_))
	}

    /// <summary>
	/// Converts an oracle of type OracleState to OracleStateDeterministic
	/// </summary>
    operation _OracleStateDeterministicFromOracleState(idxQubitFlag: Int, oracleState : OracleState, qubitsStart: Qubit[]) : (){
		Body{
			oracleState(idxQubitFlag, qubitsStart)
		}
		Adjoint auto
		Controlled auto
		Adjoint Controlled auto
	}

	function OracleStateDeterministicFromOracleState(idxQubitFlag: Int, oracleState : OracleState) : OracleStateDeterministic{
		return OracleStateDeterministic(_OracleStateDeterministicFromOracleState(idxQubitFlag, oracleState,_))
	}

    /// <summary>
	/// Converts an oracle of type OracleStateDeterministic to OracleState
	/// </summary>
    operation _OracleStateFromOracleStateDeterministic(idxQubitFlag : Int, oracleStateDeterministic : OracleStateDeterministic, qubits: Qubit[]): ()
	{
		Body{
			oracleStateDeterministic(qubits)
		}
		Adjoint auto
		Controlled auto
		Controlled Adjoint auto
	}
    function OracleStateFromOracleStateDeterministic(oracleStateDeterministic : OracleStateDeterministic) : OracleState {
		return OracleState(_OracleStateFromOracleStateDeterministic(_, oracleStateDeterministic,_))
	}

    /// <summary>
	/// Constructs a reflection about the all-zero string |0...0>, which is the typical input state to amplitude amplification.
	/// </summary>
	/// <param name = "phase"> Phase of partial reflection </param>
	/// <param name = "qubits"> Qubits of all-zero string </param>
	/// <remarks> 
	/// -
	/// </remarks>
    operation _ReflectionStart(phase: Double, qubits: Qubit[] ) : () {
		Body{
			ReflectionAllZero( phase, qubits )
		}
		Adjoint auto
		Controlled auto
		Adjoint Controlled auto
	}
	function ReflectionStart() : OracleReflection {
		return OracleReflection(_ReflectionStart( _, _ ))
	}

	/// <summary>
	/// Constructs reflection about a some state |ψ> from the oracle of type "OracleStateDeterministic" where O|0> = |ψ>
	/// </summary>
	/// <param name = "phase"> Phase of partial reflection </param>
	/// <param name = "oracle"> Oracle of type "OracleStateDeterministic" </param>
	/// <param name = "qubitsSystem"> Qubits acted on by "oracle" </param>
	/// <remarks> 
	/// -
	/// </remarks>
	operation ReflectionStartOracleStateDeterministicImpl(phase: Double, oracle: OracleStateDeterministic, qubitsSystem: Qubit[]): ()
	{
		Body {
			WithCA((Adjoint oracle), ReflectionAllZero(phase, _), qubitsSystem)
		}
		Adjoint auto
		Controlled auto
		Adjoint Controlled auto
	}
	function ReflectionStartOracleStateDeterministic(oracle: OracleStateDeterministic): OracleReflection
	{
		return OracleReflection(ReflectionStartOracleStateDeterministicImpl(_, oracle, _ ))
	}

	/// <summary>
	/// Constructs reflection about the target state uniquely marked by the flag qubit state |1>_f, prepared the oracle of type "OracleState"
	/// </summary>
	/// <param name = "phase"> Phase of partial reflection </param>
	/// <param name = "idxQubitFlag"> Index to flag qubit of oracle </param>
	/// <param name = "qubitsSystem"> All other qubits acted on by oracle </param>
	/// <remarks> 
	/// -
	/// </remarks>
	operation ReflectionTargetOracleStateImpl(phase: Double, idxQubitFlag : Int, qubits: Qubit[]): ()
	{
		Body {
			R1(phase, qubits[idxQubitFlag])
		}

		Adjoint auto
		Controlled auto
		Adjoint Controlled auto
	}
	function ReflectionTargetOracleState(idxQubitFlag : Int): OracleReflection
	{
		return OracleReflection(ReflectionTargetOracleStateImpl( _ , idxQubitFlag , _ ))
	}

}
namespace Microsoft.Quantum.Canon {
	open Microsoft.Quantum.Primitive

	/// <summary>
	/// Represents a reflection oracle.
	/// </summary>
	/// <remarks> 
	/// This oracle O = I - (1 - e^(- i ϕ)) |ψ><ψ| performs a partial reflection by phase ϕ about a single pure state |ψ>. 
	/// The first parameter is ϕ. The second parameter is the qubit register of  |ψ>.
	/// </remarks>
	newtype OracleReflection = ((Double, Qubit[]) => (): Adjoint,Controlled)

	///This oracle O|s>_a|ψ>_s = λ |t>_a U |ψ>_s + ... acts on the ancilla state |s>_a to implement the unitary U on any system state |ψ>_s with amplitude λ in the |t>_a basis.

	/// <summary>
	/// Represents an oracle for oblivious amplitude amplification.
	/// </summary>
	/// <remarks> 
	/// This oracle defined by O|s>_a|ψ>_s = λ |t>_a U |ψ>_s + ... acts on the ancilla state |s>_a to implement the unitary U on any system state |ψ>_s with amplitude λ in the |t>_a basis.
	/// The first parameter is the qubit register of |s>_a. The second parameter is the qubit register of |ψ>_s.
	/// </remarks>
	newtype OracleOblivious = ((Qubit[], Qubit[]) => (): Adjoint, Controlled)

	/// <summary>
	/// Represents an oracle for state preparation.
	/// </summary>
	/// <remarks> 
	///This oracle defined by O|0>_f|0>_s = λ |1>_f |ψ>_s + ... acts on the on computational basis state |0>_f|0>_s to create the system state |ψ>_s with amplitude λ in the basis flagged by |1>_f.
	/// The first parameter is the qubit register of |0>_f. The second parameter is the qubit register of |0>_s.
	/// </remarks>
	newtype OracleState = ((Int, Qubit[]) => (): Adjoint, Controlled)

	/// <summary>
	/// Represents an oracle for deterministic state preparation.
	/// </summary>
	/// <remarks> 
	///This oracle defined by O|0> = |ψ> acts on the on computational basis state |0> to create the state |ψ>.
	/// The first parameter is the qubit register of |ψ>.
	/// </remarks>
	newtype OracleStateDeterministic = (Qubit[] => (): Adjoint, Controlled)


	/// <summary>
	/// Phases for a sequence of partial reflections in amplitude amplification.
	/// </summary>
	/// <remarks> 
	/// The first parameter is an array of phases for reflection about the start state. The second parameter is an array of phases for reflection about the target state.
	/// Both arrays must be of equal length. Note that in many cases, the first phase about the start state and last phase about the target state introduces a global phase shift and may be set to 0. 
	/// </remarks>
	newtype AmpAmpReflectionPhases = (Double[], Double[])

	/// <summary>
	/// Phases for a sequence of single-qubit rotations in amplitude amplification.
	/// </summary>
	/// <remarks> 
	/// The first parameter is an array of phases for reflections, expressed as a product of single-qubit rotations.
	/// [ G.H. Low, I. L. Chuang, https://arxiv.org/abs/1707.05391].
	/// </remarks>
	newtype AmpAmpRotationPhases = (Double[])

	/// <summary>
	/// Applies an "OracleState" type by passing in all qubits and an index to the flag qubit.
	/// </summary>
	/// <param name = "oracle"> Oracle of type "OracleState" </param>
	/// <param name = "idxFlag"> index to flag qubit of "oracle" </param>
	/// <param name = "qubits"> All qubits acted on by "oracle" </param>


    operation _OracleObliviousFromOracleStateDeterministic(oracleAncilla : OracleStateDeterministic, oracleSignal : OracleOblivious, qubitsAncilla: Qubit[], qubitsSystem: Qubit[]) : (){
		Body{
				oracleAncilla(qubitsAncilla)
				oracleSignal(qubitsAncilla, qubitsSystem)
		}
		Adjoint auto
		Controlled auto
		Adjoint Controlled auto
	}

	function OracleObliviousFromOracleStateDeterministic(oracleAncilla : OracleStateDeterministic, oracleSignal : OracleOblivious) : OracleOblivious{
		return OracleOblivious(_OracleObliviousFromOracleStateDeterministic(oracleAncilla, oracleSignal,_,_))
	}

    
    operation _OracleStateDeterministicFromOracleState(idxQubitFlag: Int, oracleState : OracleState, qubitsStart: Qubit[]) : (){
		Body{
			oracleState(idxQubitFlag, qubitsStart)
		}
		Adjoint auto
		Controlled auto
		Adjoint Controlled auto
	}

	function OracleStateDeterministicFromOracleState(idxQubitFlag: Int, oracleState : OracleState) : OracleStateDeterministic{
		return OracleStateDeterministic(_OracleStateDeterministicFromOracleState(idxQubitFlag, oracleState,_))
	}

    operation _OracleStateFromOracleStateDeterministic(idxQubitFlag : Int, oracleStateDeterministic : OracleStateDeterministic, qubits: Qubit[]): ()
	{
		Body{
			oracleStateDeterministic(qubits)
		}
		Adjoint auto
		Controlled auto
		Controlled Adjoint auto
	}
    function OracleStateFromOracleStateDeterministic(oracleStateDeterministic : OracleStateDeterministic) : OracleState {
		return OracleState(_OracleStateFromOracleStateDeterministic(_, oracleStateDeterministic,_))
	}

    operation _ReflectionStart(phase: Double, qubits: Qubit[] ) : () {
		Body{
			ReflectionAllZero( phase, qubits )
		}
		Adjoint auto
		Controlled auto
		Adjoint Controlled auto
	}
	function ReflectionStart() : OracleReflection {
		return OracleReflection(_ReflectionStart( _, _ ))
	}

	/// <summary>
	/// Constructs reflection about a some state |ψ> from the oracle of type "OracleStateDeterministic" where O|0> = |ψ>
	/// </summary>
	/// <param name = "phase"> Phase of partial reflection </param>
	/// <param name = "oracle"> Oracle of type "OracleStateDeterministic" </param>
	/// <param name = "qubitsSystem"> Qubits acted on by "oracle" </param>
	/// <remarks> 
	/// -
	/// </remarks>
	operation ReflectionStartOracleStateDeterministicImpl(phase: Double, oracle: OracleStateDeterministic, qubitsSystem: Qubit[]): ()
	{
		Body {
			WithCA((Adjoint oracle), ReflectionAllZero(phase, _), qubitsSystem)
		}
		Adjoint auto
		Controlled auto
		Adjoint Controlled auto
	}
	function ReflectionStartOracleStateDeterministic(oracle: OracleStateDeterministic): OracleReflection
	{
		return OracleReflection(ReflectionStartOracleStateDeterministicImpl(_, oracle, _ ))
	}

	/// <summary>
	/// Constructs reflection about a some state |ψ> from the oracle of type "OracleState" where O|0>_f|0>_s = |ψ>_fs
	/// </summary>
	/// <param name = "phase"> Phase of partial reflection </param>
	/// <param name = "oracle"> Oracle of type "OracleState" </param>
	/// <param name = "qubitsFlag"> Flag qubit of "oracle" </param>
	/// <param name = "qubitsSystem"> All other qubits acted on by "oracle" </param>
	/// <remarks> 
	/// -
	/// </remarks>
	operation ReflectionStartOracleStateImpl(phase: Double, idxQubitFlag : Int, oracle: OracleState, qubits: Qubit[]): ()
	{
		Body{
			//let op = OracleStateDeterministic(OracleStateIdxFlag(idxQubitFlag, oracle, _))
			//(ReflectionStartOracleStateDeterministic(op))(phase, qubits)
		}
		Adjoint auto
		Controlled auto
		Adjoint Controlled auto
	}
	function ReflectionStartOracleState(idxQubitFlag : Int, oracle: OracleState): OracleReflection
	{
		return OracleReflection(ReflectionStartOracleStateImpl( _ , idxQubitFlag , oracle , _ ))
	}

	/// <summary>
	/// Constructs reflection about the target state uniquely marked by the flag qubit state |1>_f, prepared the oracle of type "OracleState"
	/// </summary>
	/// <param name = "phase"> Phase of partial reflection </param>
	/// <param name = "qubitsFlag"> Flag qubit of oracle </param>
	/// <param name = "qubitsSystem"> All other qubits acted on by oracle </param>
	/// <remarks> 
	/// -
	/// </remarks>
	operation ReflectionTargetOracleStateImpl(phase: Double, idxQubitFlag : Int, qubits: Qubit[]): ()
	{
		Body {
			R1(phase, qubits[idxQubitFlag])
		}

		Adjoint auto
		Controlled auto
		Adjoint Controlled auto
	}
	function ReflectionTargetOracleState(idxQubitFlag : Int): OracleReflection
	{
		return OracleReflection(ReflectionTargetOracleStateImpl( _ , idxQubitFlag , _ ))
	}

}
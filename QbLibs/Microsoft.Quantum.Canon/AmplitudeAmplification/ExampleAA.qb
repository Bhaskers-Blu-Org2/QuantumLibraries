namespace Microsoft.Quantum.Canon {
	open Microsoft.Quantum.Primitive

	///Here we consider the smallest example of amplitude amplification
	///Suppose we have a single-qbuit oracle that prepares the state
	/// O |0> = \lambda |1> + \sqrt{1-|\lambda|^2} |0>
	/// The goal is to amplify the |1> state
	/// We can do this either by synthesizing the reflection about the start and target states ourselves,
	/// We can also do it by passing the oracle for state preparation
 
	operation ExampleStatePrepImpl( lambda : Double, idxQubitFlag : Int , qubitStart : Qubit[] ) : ()
	{
		Body
		{
			let rotAngle = 2.0 * ArcSin(lambda)
			Ry(rotAngle, qubitStart[idxQubitFlag])
		}

		Adjoint auto
		Controlled auto
		Adjoint Controlled auto
 
	}
	function ExampleStatePrep( lambda : Double ) : OracleState
	{
		return OracleState( ExampleStatePrepImpl (lambda, _, _) )
 
	}
 
	///In this minimal example, there are no system qubits, only a single flag qubit. 
	/// ExampleStatePrep is already of type  OracleState, so we call
	/// AmpAmpByOracle(iterations: Int, oracleState : OracleState, idxQubitFlag : Int qubitsStart: Qubit[]) : ()
    operation AmpAmpByOracleTest() : ()
	{
		Body{
			
			using(qubits = Qubit[1]){
				ResetAll(qubits)
				for(nIterations in 0..5){


					for(idx in 1..20){
						let lambda = ToDouble(idx) / 20.0
                        let rotAngle = ArcSin(lambda)
						let idxFlag = 0
						let qubitsStart = qubits


						let oracleState = ExampleStatePrep(lambda)
						

						(AmpAmpByOracle(nIterations, oracleState, idxFlag))( qubitsStart)
						
						let successAmplitude = Sin( ToDouble(2 * nIterations + 1) * rotAngle )
						let successProbability = successAmplitude * successAmplitude
						AssertProb([Zpauli], [qubitsStart[idxFlag]], One, successProbability, "Error: Success probability does not match theory", 1e-10)

						ResetAll(qubits)
					}
				}
			}
		}
	}

	operation AmpAmpObliviousByOraclePhasesTest() : ()
	{
		Body{
			
			using(qubits = Qubit[1]){
				ResetAll(qubits)
				for(nIterations in 0..5){
					let phases = AmpAmpPhasesStandard(nIterations)
					for(idx in 0..20){
						let rotAngle = ToDouble(idx) * Pi() / 20.0
						let idxFlag = 0
						let qubitsAncilla = qubits
						let qubitsSystem = new Qubit[0]

						let oracleAncilla = OracleStateDeterministic(Exp([Ypauli], rotAngle * 0.5, _))
						let oracleSignal = OracleOblivious(Identity2(_,_))

						(AmpAmpObliviousByOraclePhases(phases, oracleAncilla, oracleSignal, idxFlag))(qubitsAncilla, qubitsSystem)
				
						let successAmplitude = Sin( ToDouble(2 * nIterations + 1) * rotAngle * 0.5 )
						let successProbability = successAmplitude * successAmplitude
						AssertProb([Zpauli], [qubitsAncilla[idxFlag]], One, successProbability, "Error: Success probability does not match theory", 1e-10)

						ResetAll(qubits)
					}
				}
			}
		}
	}

	operation AmpAmpReflectionTargetOracleStateTest(): ()
	{
		Body{
			using(qubits = Qubit[1]){
				ResetAll(qubits)
				for(idx in 0..20){
					let rotangle = ToDouble(idx) * Pi() / 20.0
					let refTarget = ReflectionTargetOracleState(0)

					let success = Cos(0.5 * rotangle) * Cos(0.5 * rotangle)

					H(qubits[0])
					refTarget(rotangle,qubits)
					AssertProb([Xpauli], qubits, Zero, success, "Error: Success probability does not match theory", 1e-10)
					ResetAll(qubits)
				}
			}
		}
	}

}

namespace Microsoft.Quantum.Canon {
    open Microsoft.Quantum.Primitive

    // Overview of amplitude amplification library
    // ===========================================
    //
    // Oblivious amplitude amplification with partial reflections is the most general form of amplitude amplification implemented here.
    // This is called through the operation AmpAmpObliviousByReflectionPhases.
    //
    //		This has two registers: "ancillaRegister" and "systemRegister".
    //		This accepts two oracles for these reflections of type "ReflectionOracle" which act only on the "ancillaRegister" register.
    //		This accepts an oracle special to oblivious amplitude amplification of type "ObliviousOracle" which acts jointly on both register.
    //		The input state to "ancillaRegister" is assumed to be the unique -1 eigenstate of the first reflection operator I - 2|s〉〈s|.
    //
    // Reflections about a target quantum state are often implemented by assuming access to an oracle that prepare that state from the computational basis |0...0〉.
    //		Our convention for these oracles requires two registers: a single-qubit "flagQubit" register, and a register for everything else on the ancillaRegister register.
    //		The oracle of type "StateOracle" acts jointly on both registers to create the target state flagged by |1> in the "flagQubit" register with some real amplitude.
    //		The reflection "ReflectionOracle" about the this flag state is generated by the operation "TargetStateReflectionOracle"
    //		The reflection "ReflectionOracle" about the input state to "ancillaRegister" is generated by the inverting StateOracle and then reflecting about |0...0〉 with ReflectionStart()
    //		The oracle of type "DeterministicStateOracle" acts on the "qubitState" registers to create the target state exactly with no flag.
    //
    // "AmpAmpObliviousByOraclePhases" is a version of oblivious amplitude amplification that accepts oracles "StateOracle" and "ObliviousOracle" instead of reflections.
    //
    // Note that amplitude amplification is a special case of oblivious amplitude amplifiction where "ObliviousOracle" is the identity operator, and there are no system qubits i.e. "systemRegister" is empty.
    //		This is called through the operaton "AmpAmByReflectionPhases" and "AmpAmpByOraclePhases".
    //
    // The phases for partial reflections in the standard case of Grover search is provided by the function AmpAmpPhasesStandard.
    // For instance, we have the following dependencies: AmpAmpByOracle -> AmpAmpByOraclePhases -> AmpAmpObliviousByOraclePhases -> AmpAmpObliviousByReflectionPhases


    // TODO: Different parameter choice for fixed-point
    // TODO: Amplitude estimation -- easiest way to is to use quantum phase estimation libary on Grover Iterate as the oracle

    /// <summary>
    ///     Converts phases specified as single-qubit rotations to phases specified as partial reflections.
    /// </summary>
    /// <param name="rotPhases">Array of single-qubit rotations to be cibverted to partial reflections.</param>
    /// <remarks>
    ///     We use the convention in [ G.H. Low, I. L. Chuang, https://arxiv.org/abs/1707.05391] for relating single-qubit rotation phases to reflection operator phases.
    /// </remarks>
    function AmpAmpRotationToReflectionPhases( rotPhases : AmpAmpRotationPhases) : AmpAmpReflectionPhases
    {
        let nPhasesRot = Length(rotPhases)
        let nPhasesRef = (nPhasesRot + 1) / 2

        if (nPhasesRot % 2 == 0) {
            fail "Number of rotations must be odd."
        }

        mutable phasesTarget = new Double[nPhasesRef]
        mutable phasesStart = new Double[nPhasesRef]

        set phasesTarget[0] = rotPhases[0] - rotPhases[1] - Pi()
        set phasesStart[0] = - rotPhases[0] + 0.5 * Pi()

        for (idxPhases in 1..nPhasesRef - 2){
            set phasesTarget[idxPhases] = rotPhases[2*idxPhases] - rotPhases[2*idxPhases + 1] - Pi()
            set phasesStart[idxPhases] = rotPhases[2*idxPhases-1] - rotPhases[2*idxPhases] + Pi()
        }

        set phasesTarget[nPhasesRef-1] = rotPhases[2*nPhasesRef-2] - 0.5 * Pi()
        set phasesStart[nPhasesRef-1] = rotPhases[2*nPhasesRef-3] - rotPhases[2*nPhasesRef-2] + Pi()

        return AmpAmpReflectionPhases(phasesStart, phasesTarget)
    }


    /// <summary>
    ///     Computes partial reflection phases for standard amplitude amplification.
    /// </summary>
    /// <param name="nIterations">
    ///     Number of amplitude amplification iterations to generate partial reflection
    ///     phases for.
    /// </param>
    /// <remarks>
    ///     All phases are π, except for the first reflection about the start state and the last reflection about the target state, which are 0.
    /// </remarks>
    function AmpAmpPhasesStandard(nIterations : Int) : AmpAmpReflectionPhases{
        mutable phasesTarget = new Double[nIterations+1]
        mutable phasesStart = new Double[nIterations+1]


        for (idxPhases in 0..nIterations){
            set phasesTarget[idxPhases] = Pi()
            set phasesStart[idxPhases] = Pi()
        }
        set phasesTarget[nIterations] = 0.0
        set phasesStart[0] = 0.0

        return AmpAmpReflectionPhases(phasesStart, phasesTarget)
    }


    // We use the phases in "Fixed-Point Amplitude Amplification with an Optimal Number of Queires" [YoderLowChuang2014]
    // See also "Methodology of composite quantum gates" [LowYoderChuang2016] for phases in the "AmpAmpRotationPhases" format

    /// summary:
    ///     Computes partial reflection phases for fixed-point amplitude amplification.
    /// params:
    ///     nQueries: Number of queries to the state preparation oracle. Must be an odd integer.
    ///     successMin:Target minimum success probability.
    /// remarks:
    ///     We use the phases in "Fixed-Point Amplitude Amplification with
    ///     an Optimal Number of Queires" [YoderLowChuang2014, https://arxiv.org/abs/1409.3305].
    ///     See also "Methodology of composite quantum gates" [LowYoderChuang2016, https://arxiv.org/abs/1603.03996]
    ///     for phases in the "AmpAmpRotationPhases" format.
    function AmpAmpPhasesFixedPoint( nQueries: Int, successMin: Double ) : AmpAmpReflectionPhases
    {
        mutable phasesRot = new Double[nQueries]

        let nQueriesDouble = ToDouble(nQueries)
        set phasesRot[0] = 0.0

        let beta = Cosh(1.0 / nQueriesDouble * ArcCosh( Sqrt(successMin) ))

        for (idxPhases in 1..nQueries - 1){
            set phasesRot[idxPhases] = phasesRot[idxPhases - 1] + 2.0 * ArcTan( Tan( 2.0 * 1.0 * ToDouble(idxPhases) * Pi() / nQueriesDouble ) * Sqrt(1.0 - beta * beta))
        }

        return AmpAmpRotationToReflectionPhases(AmpAmpRotationPhases(phasesRot))
    }



    /// <summary>
    /// Oblivious amplitude amplification by specifying partial reflections.
    /// </summary>
    /// <param name = "phases"> Phases of partial reflections </param>
    /// <param name = "ancillaReflection"> Reflection operator about start state of ancilla register </param>
    /// <param name = "targetStateReflection"> Reflection operator about target state of ancilla register </param>
    /// <param name = "signalOracle"> Unitary oracle of type "ObliviousOracle" that acts jointly on the ancilla and system registers.</param>
    /// <param name = "ancillaRegister"> Ancilla register </param>
    /// <param name = "systemRegister"> System register </param>
    /// <remarks> 
    /// Given a particular ancilla start state |start>_a, a particular ancilla target state |target>_a, and any system state |ψ>_s,
    /// suppose that signalOracle|start>_a|ψ>_s= λ|target>_a U|ψ>_s + sqrt{1-|λ|^2}... for some unitary U.
    /// By a sequence of reflections about the start and target states on the ancilla register interleaved by applications of "signalOracle" and its adjoint, the success probability of applying U may be altered.
    /// In most cases, "ancillaRegister" is initialized in the state |start>_a.
    /// See [Dominic W. Berry, Andrew M. Childs, Richard Cleve, Robin Kothari, Rolando D. Somma, https://arxiv.org/abs/1312.1414] for standard version.
    /// See [G.H. Low, I.L. Chuang, https://arxiv.org/abs/1610.06546] for generalization to partial reflections.
    /// </remarks>
    operation AmpAmpObliviousByReflectionPhasesImpl(phases : AmpAmpReflectionPhases, ancillaReflection : ReflectionOracle, targetStateReflection : ReflectionOracle, signalOracle : ObliviousOracle, ancillaRegister: Qubit[], systemRegister: Qubit[]) : ()
    {
        Body {
            let (phasesAncilla, phasesTarget) = phases
            let nphases = 2 * Length(phasesTarget)

            //FailOn(nphases != Length(phasesAncilla), "Phase array lengths not equal.")
    
            if(phasesAncilla[0] != 0.0) {
                ancillaReflection(phasesAncilla[0], ancillaRegister)
            }
    
            for (idxPhases in 1..nphases - 1){
                let idxPhaseAncilla = (idxPhases / 2)
                let idxPhaseTarget = idxPhases / 2

                if(idxPhases%2 == 1){
                    signalOracle(ancillaRegister, systemRegister)
                    if(phasesTarget[idxPhaseTarget] != 0.0) {
                        targetStateReflection(phasesTarget[idxPhaseTarget], ancillaRegister)
                    }
                }
                else{
                    (Adjoint signalOracle)(ancillaRegister, systemRegister)
                    if(phasesAncilla[idxPhaseAncilla] != 0.0) {
                        ancillaReflection(phasesAncilla[idxPhaseAncilla], ancillaRegister)
                    }
                }

            }
        }

        Adjoint auto
        Controlled auto
        Adjoint Controlled auto
    }

    function AmpAmpObliviousByReflectionPhases(phases : AmpAmpReflectionPhases, ancillaReflection : ReflectionOracle, targetStateReflection : ReflectionOracle, signalOracle : ObliviousOracle) : ((Qubit[], Qubit[]) => () : Adjoint, Controlled)
    {
        return AmpAmpObliviousByReflectionPhasesImpl(phases, ancillaReflection, targetStateReflection, signalOracle, _, _) 
    }


    /// <summary>
    /// Oblivious amplitude amplification by oracles for partial reflections.
    /// </summary>
    /// <param name = "phases"> Phases of partial reflections </param>
    /// <param name = "ancillaOracle"> Unitary oracle that prepares ancilla start state </param>
    /// <param name = "signalOracle"> Unitary oracle of type "ObliviousOracle" that acts jointly on the ancilla and system registers.</param>
    /// <param name = "idxFlagQubit"> Index to single-qubit flag register </param>
    /// <param name = "ancillaRegister"> Ancilla register </param>
    /// <param name = "systemRegister"> System register </param>
    /// <remarks> 
    /// This imposes stricter conditions on form of the ancilla start and target states than in "AmpAmpObliviousByReflectionPhases".
    /// It is assumed that ancillaOracle|0>_f|0>_a = |start>_fa prepares the ancilla start state |start>_fa from the computational basis |0>_f|0>_a.
    /// It is assumed that the target state is marked by |1>_f.
    /// It is assumed that signalOracle|start>_fa|ψ>_s = λ|1>_f|anything>_a U|ψ>_s + sqrt{1-|λ|^2}|0>_f...
    /// In most cases, "flagQubit" and "ancillaRegister" is initialized in the state |0>_f|0>_a.
    /// </remarks>
  
    function AmpAmpObliviousByOraclePhases(phases : AmpAmpReflectionPhases, ancillaOracle : DeterministicStateOracle, signalOracle : ObliviousOracle, idxFlagQubit : Int) : ((Qubit[], Qubit[]) => () : Adjoint, Controlled)
    {
        let ancillaReflection = ReflectionStart()
        let targetStateReflection = TargetStateReflectionOracle(idxFlagQubit)
        let oracleObliviousNew = ObliviousOracleFromDeterministicStateOracle(ancillaOracle, signalOracle)

        return AmpAmpObliviousByReflectionPhases(phases, ancillaReflection, targetStateReflection, oracleObliviousNew)
    }

    /// <summary>
    /// Amplitude amplification by partial reflections.
    /// </summary>
    /// <param name = "phases"> Phases of partial reflections </param>
    /// <param name = "startStateReflection"> Reflection operator about start state </param>
    /// <param name = "targetStateReflection"> Reflection operator about target state </param>
    /// <param name = "startQubits"> Qubit register </param>
    /// <remarks> 
    /// Amplitude amplification is a special case of oblivous amplitude amplification where there are no system qubits and the oblivious oracle is set to identity.
    /// In most cases, "startQubits" is initialized in the state |start>_a, which is the -1 eigenstate of "startStateReflection"
    /// </remarks>
    function AmpAmpByReflectionsPhases(phases : AmpAmpReflectionPhases, startStateReflection : ReflectionOracle, targetStateReflection : ReflectionOracle) :  (Qubit[] => () : Adjoint, Controlled)
    {
        
        //Pass empty qubit array using fact that NoOp2 does nothing
        let qubitEmpty = new Qubit[0]

        let signalOracle = ObliviousOracle(NoOp2)

        return (AmpAmpObliviousByReflectionPhases(phases, startStateReflection, targetStateReflection, signalOracle))(_, qubitEmpty)
    }

    /// <summary>
    /// Amplitude amplification by oracles for partial reflections.
    /// </summary>
    /// <param name = "phases"> Phases of partial reflections </param>
    /// <param name = "statePrepOracle"> Unitary oracle that prepares start state </param>
    /// <param name = "idxFlagQubit"> Index to Flag qubit </param>
    /// <param name = "qubits"> Start state register </param>
    /// <remarks> 
    /// This imposes stricter conditions on form of the start and target states than in "AmpAmpByReflectionPhases".
    /// It is assumed that the target state is marked by |1>_f.
    /// It is assumed that statePrepOracle|0>_f|0>_s = λ|1>_f|target>__s + sqrt{1-|λ|^2}|0>_f...
    /// In most cases, "flagQubit" and "ancillaRegister" is initialized in the state |0>_f|0>_a.
    /// </remarks>
    function AmpAmpByOraclePhases(phases : AmpAmpReflectionPhases, stateOracle : StateOracle, idxFlagQubit : Int) :  (Qubit[] => () : Adjoint, Controlled)
    {
        
        let qubitEmpty = new Qubit[0]
        let signalOracle = ObliviousOracle(NoOp2)
        let ancillaOracle = DeterministicStateOracleFromStateOracle(idxFlagQubit, stateOracle)
    
        return (AmpAmpObliviousByOraclePhases(phases, ancillaOracle, signalOracle, idxFlagQubit))(_, qubitEmpty)

    
    }

    /// <summary>
    /// Standard Amplitude Amplification algorithm
    /// </summary>
    /// <param name = "nIterations"> Number of iterations of amplitude amplification </param>
    /// <param name = "statePrepOracle"> Unitary oracle that prepares start state </param>
    /// <param name = "idxFlagQubit"> Index to Flag qubit </param>
    /// <param name = "qubits"> Start state register </param>
    /// <remarks> 
    /// This is the standard amplitude amplification algorithm obtained by a choice of reflection phases computed by "AmpAmpPhasesStandard"
    /// Assuming that statePrepOracle|0>_f|0>_s = λ|1>_f|target>__s + sqrt{1-|λ|^2}|0>_f... = sin(θ)|1>_f|target>__s + cos(θ)|0>_f...,
    /// this operation prepares the state AmpAmpByOracle|0>_f|0>_s = sin(2*nIterations+1)|1>_f|target>__s + cos(2*nIterations+1)|0>_f...,
    /// In most cases, "flagQubit" and "ancillaRegister" is initialized in the state |0>_f|0>_a.
    /// [G. Brassard, P. Hoyer, M. Mosca, A. Tapp, https://arxiv.org/abs/quant-ph/0005055]
    /// </remarks>
    function AmpAmpByOracle(nIterations: Int, stateOracle : StateOracle, idxFlagQubit : Int) : (Qubit[] => () : Adjoint, Controlled)
    {
        let phases = AmpAmpPhasesStandard(nIterations)
        return AmpAmpByOraclePhases(phases, stateOracle, idxFlagQubit)
    }

    /// <summary>
    /// Fixed-Point Amplitude Amplification algorithm 
    /// </summary>
    /// <param name = "statePrepOracle"> Unitary oracle that prepares start state </param>
    /// <param name = "startQubits"> Qubit register </param>
    /// <remarks> 
    /// startQubits must be in the |0..0> state. This iterates over a number of queries in powers of 2 until queriesMax 
    /// is reached, or the target state is found.
    /// </remarks>
    /// TODO test this.
    operation AmpAmpRUSByOracle(statePrepOracle : StateOracle, startQubits: Qubit[]) : ()
    {
        Body {
            let queriesMax = 999 // Should be a power of 2
            let successMin = 0.99
            mutable finished = Zero
            mutable exponentMax = 0
            mutable exponentCurrent = 0

            //Complexity: Let \theta = \mathcal{O}(\sqrt{lambda}) 
            // Number of Measurements = O( Log^2(1/\theta) )
            // Number of Queries = O(1/\theta)
        
            using( flagQubit = Qubit[1] ) {
                let qubits = flagQubit + startQubits
                let idxFlagQubit = 0
                repeat { 
                    if( 2 ^ exponentMax > queriesMax ) {
                        fail "Target state not found. Maximum number of queries exceeded."
                    }
                    repeat { 
                        let queries = 2 ^ exponentCurrent
                        let phases = AmpAmpPhasesFixedPoint( queries, successMin ) 
                        (AmpAmpByOraclePhases(phases, statePrepOracle, idxFlagQubit))(qubits)

                        set finished = M(flagQubit[0])
                        set exponentCurrent = exponentCurrent + 1
                    } 
                    until(finished == One || exponentCurrent > exponentMax)
                    fixup {
                        // flagQubit is already in Zero for fixup to apply
                        ResetAll(startQubits)
                    }
            
                    set exponentCurrent = 0
                    set exponentMax = exponentMax + 1
                } 
                until(finished == One)
                fixup {
                    ResetAll(startQubits)
                }
            }

        }
    }

}
namespace Microsoft.Quantum.Canon {
	open Microsoft.Quantum.Primitive

	// Overview of amplitude amplification library
	// Oblivious amplitude amplification with partial reflections is the most general form of amplitude amplification implemented here
	// This is called through the operation AmpAmpObliviousByReflectionPhases.
	//		This has two registers: "qubitsAncilla" and "qubitsSystem".
	//		This accepts two oracles for these reflections of type "OracleReflection" which act only on the "qubitsAncilla" register.
	//		This accepts an oracle special to oblivious amplitude amplification of type "OracleOblivious" which acts jointly on both register.
	//		The input state to "qubitsAncilla" is assumed to be the unique -1 eigenstate of the first reflection operator.
	//
	// Reflections about a quantum state are often implemented by assuming access to an oracle that prepare that state from the computational basis |0...0>.
	//		Our convention for these oracles requires two registers: a single-qubit "qubitFlag" register, and "qubitsState".
	//		The oracle of type "OracleState" acts jointly on both registers to create the target state flagged by |1> in the "qubitFlag" register with some real ampitude. 
	//		The reflection "OracleReflection" about the this flag state is generated by the operation "ReflectionTargetForOracleState"
	//		The reflection "OracleReflection" about the input state to "qubitsAncilla" is generated by the operation "ReflectionFromOracleState"
	//		The oracle of type "OracleStateDeterministic" acts on the "qubitState" registers to create the target state exactly with no flag. 
	//
	// "AmpAmpObliviousByOraclePhases" is a version of oblivious amplitude amplification that accepts oracles "OracleState" and "OracleOblivious" instead of reflections.
	//
	// Note that amplitude amplification is a special case of oblivious amplitude amplifiction where "OracleOblivious" is the identity operator, and there are no system qubits i.e. "qubitsSystem" is empty.
	//		This is called through the operaton "AmpAmByReflectionPhases" and "AmpAmpByOraclePhases".
	//
	// The phases for partial reflections in the standard case of Grover search is provided by the function AmpAmpPhasesStandard
	//		An example
	// The operation AmpAmpObliviousByReflections calls AmpAmpObliviousByReflectionPhases with phases given by AmpAmpPhasesStandard
	// 

	// TODO: Different parameter choice for fixed-point
	// TODO: Unittests for amplitudeamplification routines
	// TODO: Amplitude estimation -- easiest way to is to use quantum phase estimation libary on Grover Iterate as the oracle
	// TODO when Bug #692 is fixed: Make combinators for implementations

	/// <summary>
	/// Converts phases specified as single-qubit rotations to phases as partial reflections
	/// </summary>
	/// <param name = "rotPhases"> Phase array </param>
	/// <remarks> 
	/// We use the convention in [ G.H. Low, I. L. Chuang, https://arxiv.org/abs/1707.05391] for relating single-qubit rotation phases to reflection operator phases.
	/// </remarks>
	function AmpAmpRotationToReflectionPhases( rotPhases : AmpAmpRotationPhases) : AmpAmpReflectionPhases
	{
		let nPhasesRot = Length(rotPhases)
		let nPhasesRef = (nPhasesRot + 1) / 2
	
		//FailOn(nPhasesRot % 2 == 0, "Number of rotations must be odd.")

		mutable phasesTarget = new Double[nPhasesRef]
		mutable phasesStart = new Double[nPhasesRef]

		set phasesTarget[0] = rotPhases[0] - rotPhases[1] - Pi()
		set phasesStart[0] = - rotPhases[0] + 0.5 * Pi()

		for (idxPhases in 1..nPhasesRef-2){
			set phasesTarget[idxPhases] = rotPhases[2*idxPhases] - rotPhases[2*idxPhases + 1] - Pi()
			set phasesStart[idxPhases] = rotPhases[2*idxPhases-1] - rotPhases[2*idxPhases] + Pi()
		}

		set phasesTarget[nPhasesRef-1] = rotPhases[2*nPhasesRef-2] - 0.5 * Pi()
		set phasesStart[nPhasesRef-1] = rotPhases[2*nPhasesRef-3] - rotPhases[2*nPhasesRef-2] + Pi()

		return AmpAmpReflectionPhases(phasesStart, phasesTarget)
	}


	/// <summary>
	/// Computes partial reflection phases for standard amplitude amplification.
	/// </summary>
	/// <param name = "rotPhases"> Number of application of iterate </param>
	/// <remarks> 
	/// All phases are Pi, except for the first reflection about the start state and the last reflection about the target state, which are 0.
	/// </remarks>
	function AmpAmpPhasesStandard(iterations : Int) : AmpAmpReflectionPhases{
		mutable phasesTarget = new Double[iterations+1]
		mutable phasesStart = new Double[iterations+1]
		

		for (idxPhases in 0..iterations){
			set phasesTarget[idxPhases] = Pi()
			set phasesStart[idxPhases] = Pi()
		}
		set phasesTarget[iterations] = 0.0
		set phasesStart[0] = 0.0

		return AmpAmpReflectionPhases(phasesStart, phasesTarget)
	}


	//We use the phases in "Fixed-Point Amplitude Amplification with an Optimal Number of Queires" [YoderLowChuang2014]
	//See also "Methodology of composite quantum gates" [LowYoderChuang2016] for phases in the "AmpAmpRotationPhases" format
	//function AmpAmpPhasesFixedPoint( lambdaMin : double, SuccessMin: double ) : (double[], double[]){

	/// <summary>
	/// Computes partial reflection phases for fixed-point amplitude amplification.
	/// </summary>
	/// <param name = "queries"> Number of queries to state preparation oracle (Must be an odd integer) </param>
	/// <param name = "SuccessMin"> Target minimum success probability </param>
	/// <remarks> 
	/// We use the phases in "Fixed-Point Amplitude Amplification with an Optimal Number of Queires" [YoderLowChuang2014, https://arxiv.org/abs/1409.3305]
	/// See also "Methodology of composite quantum gates" [LowYoderChuang2016, https://arxiv.org/abs/1603.03996] for phases in the "AmpAmpRotationPhases" format
	/// </remarks>
	function AmpAmpPhasesFixedPoint( queries: Int, successMin: Double ) : AmpAmpReflectionPhases
	{
		mutable phasesRot = new Double[queries]
		let queriesDouble = Float(queries)

		set phasesRot[0] = 0.0

		let beta = Cosh(1.0 / queriesDouble * ArcCosh( Sqrt(successMin) ))

		for (idxPhases in 1..queries - 1){
			set phasesRot[idxPhases] = phasesRot[idxPhases - 1] + 2.0 * ArcTan( Tan( 2.0 * 1.0 * Float(idxPhases) * Pi() / queriesDouble ) * Sqrt(1.0 - beta * beta)) 
		}

		return AmpAmpRotationToReflectionPhases(AmpAmpRotationPhases(phasesRot))
	}


	

	/// <summary>
	/// Oblivious amplitude amplification by specifying partial reflections.
	/// </summary>
	/// <param name = "phases"> Phases of partial reflections </param>
	/// <param name = "refAncilla"> Reflection operator about start state of ancilla register </param>
	/// <param name = "refTarget"> Reflection operator about target state of ancilla register </param>
	/// <param name = "oracleSignal"> Unitary oracle of type "OracleOblivious" that acts jointly on the ancilla and system registers.</param>
	/// <param name = "qubitsAncilla"> Ancilla register </param>
	/// <param name = "qubitsSystem"> System register </param>
	/// <remarks> 
	/// Given a particular ancilla start state |start>_a, a particular ancilla target state |target>_a, and any system state |ψ>_s,
	/// suppose that oracleSignal|start>_a|ψ>_s= λ|target>_a U|ψ>_s + sqrt{1-|λ|^2}... for some unitary U.
	/// By a sequence of reflections about the start and target states on the ancilla register interleaved by applications of "oracleSignal" and its adjoint, the success probability of applying U may be altered.
	/// In most cases, "qubitsAncilla" is initialized in the state |start>_a.
	/// See [Dominic W. Berry, Andrew M. Childs, Richard Cleve, Robin Kothari, Rolando D. Somma, https://arxiv.org/abs/1312.1414] for standard version.
	/// See [G.H. Low, I.L. Chuang, https://arxiv.org/abs/1610.06546] for generalization to partial reflections.
	/// </remarks>
	operation AmpAmpObliviousByReflectionPhases(phases : AmpAmpReflectionPhases, refAncilla : OracleReflection, refTarget : OracleReflection, oracleSignal : OracleOblivious, qubitsAncilla: Qubit[], qubitsSystem: Qubit[]) : ()
	{
		Body {
			let (phasesAncilla, phasesTarget) = phases
			let nphases = 2 * Length(phasesTarget)

			//FailOn(nphases != Length(phasesAncilla), "Phase array lengths not equal.")
	
			if(phasesAncilla[0] != 0.0) {
				refAncilla(phasesAncilla[0], qubitsAncilla)
			}
	
			for (idxPhases in 1..nphases - 1){
				let idxPhaseAncilla = (idxPhases / 2)
				let idxPhaseTarget = idxPhases / 2

				if(idxPhases%2 == 1){
					oracleSignal(qubitsAncilla, qubitsSystem)
					if(phasesTarget[idxPhaseTarget] != 0.0) {
						refTarget(phasesTarget[idxPhaseTarget], qubitsAncilla)
					}
				}
				else{
					(Adjoint oracleSignal)(qubitsAncilla, qubitsSystem)
					if(phasesAncilla[idxPhaseAncilla] != 0.0) {
						refAncilla(phasesAncilla[idxPhaseAncilla], qubitsAncilla)
					}
				}

			}
		}

		Adjoint auto
		Controlled auto
		Adjoint Controlled auto
	}


	/// <summary>
	/// Oblivious amplitude amplification by oracles for partial reflections.
	/// </summary>
	/// <param name = "phases"> Phases of partial reflections </param>
	/// <param name = "oracleAncilla"> Unitary oracle that prepares ancilla start state </param>
	/// <param name = "oracleSignal"> Unitary oracle of type "OracleOblivious" that acts jointly on the ancilla and system registers.</param>
	/// <param name = "qubitFlag"> Single-qubit flag register </param>
	/// <param name = "qubitsAncilla"> Ancilla register </param>
	/// <param name = "qubitsSystem"> System register </param>
	/// <remarks> 
	/// This imposes stricter conditions on form of the ancilla start and target states than in "AmpAmpObliviousByReflectionPhases".
	/// It is assumed that oracleAncilla|0>_f|0>_a = |start>_fa prepares the ancilla start state |start>_fa from the computational basis |0>_f|0>_a.
	/// It is assumed that the target state is marked by |1>_f.
	/// It is assumed that oracleSignal|start>_fa|ψ>_s = λ|1>_f|anything>_a U|ψ>_s + sqrt{1-|λ|^2}|0>_f...
	/// In most cases, "qubitFlag" and "qubitsAncilla" is initialized in the state |0>_f|0>_a.
	/// </remarks>

	operation AmpAmpObliviousByOraclePhases(phases : AmpAmpReflectionPhases, oracleAncilla : OracleStateDeterministic, oracleSignal : OracleOblivious, idxQubitFlag : Int, qubitsAncilla: Qubit[], qubitsSystem: Qubit[]) : ()
	{
		Body {
			//Assert that qubitsAncilla are in |0...0> state?
			let qubitFlag = qubitsAncilla[idxQubitFlag]
			let refAncilla = ReflectionStart()
			let refTarget = ReflectionTargetOracleState(idxQubitFlag)
			let oracleObliviousNew = OracleObliviousFromOracleStateDeterministic(oracleAncilla, oracleSignal)

			AmpAmpObliviousByReflectionPhases(phases, refAncilla, refTarget, oracleObliviousNew, qubitsAncilla, qubitsSystem)
		
		}

		Adjoint auto
		Controlled auto
		Adjoint Controlled auto
	}

	/// <summary>
	/// Amplitude amplification by oracles for partial reflections.
	/// </summary>
	/// <param name = "phases"> Phases of partial reflections </param>
	/// <param name = "oracleStatePrep"> Unitary oracle that prepares start state </param>
	/// <param name = "idxQubitFlag"> Index to Flag qubit </param>
	/// <param name = "qubits"> Start state register </param>
	/// <remarks> 
	/// This imposes stricter conditions on form of the start and target states than in "AmpAmpByReflectionPhases".
	/// It is assumed that the target state is marked by |1>_f.
	/// It is assumed that oracleStatePrep|0>_f|0>_s = λ|1>_f|target>__s + sqrt{1-|λ|^2}|0>_f...
	/// In most cases, "qubitFlag" and "qubitsAncilla" is initialized in the state |0>_f|0>_a.
	/// </remarks>
	operation AmpAmpByOraclePhases(phases : AmpAmpReflectionPhases, oracleState : OracleState, idxQubitFlag : Int, qubitsStart: Qubit[]) : ()
	{
		Body {
            let qubitEmpty = new Qubit[0]
            let oracleSignal = OracleOblivious(Identity2)
            let oracleAncilla = OracleStateDeterministicFromOracleState(idxQubitFlag, oracleState)
	
		    AmpAmpObliviousByOraclePhases(phases, oracleAncilla, oracleSignal, idxQubitFlag, qubitsStart, qubitEmpty)

		}

		Adjoint auto
		Controlled auto
		Adjoint Controlled auto
	}


	/// <summary>
	/// Amplitude amplification by partial reflections.
	/// </summary>
	/// <param name = "phases"> Phases of partial reflections </param>
	/// <param name = "refStart"> Reflection operator about start state </param>
	/// <param name = "refTarget"> Reflection operator about target state </param>
	/// <param name = "qubitsStart"> Qubit register </param>
	/// <remarks> 
	/// Amplitude amplification is a special case of oblivous amplitude amplification where there are no system qubits and the oblivious oracle is set to identity.
	/// In most cases, "qubitsStart" is initialized in the state |start>_a, which is the -1 eigenstate of "refStart"
	/// </remarks>
	operation AmpAmpByReflectionsPhases(phases : AmpAmpReflectionPhases, refStart : OracleReflection, refTarget : OracleReflection, qubitsStart: Qubit[]) : ()
	{
		Body {
			//Pass empty qubit array using fact that Identity2 does nothing
			let qubitEmpty = new Qubit[0]

			let oracleSignal = OracleOblivious(Identity2)

			AmpAmpObliviousByReflectionPhases(phases, refStart, refTarget, oracleSignal, qubitsStart, qubitEmpty) 
		}

		Adjoint auto
		Controlled auto
		Adjoint Controlled auto
	}




	/// <summary>
	/// Standard Amplitude Amplification algorithm
	/// </summary>
	/// <param name = "iterations"> Number of iterations of amplitude amplification </param>
	/// <param name = "oracleStatePrep"> Unitary oracle that prepares start state </param>
	/// <param name = "idxQubitFlag"> Index to Flag qubit </param>
	/// <param name = "qubits"> Start state register </param>
	/// <remarks> 
	/// This is the standard amplitude amplification algorithm obtained by a choice of reflection phases computed by "AmpAmpPhasesStandard"
	/// Assuming that oracleStatePrep|0>_f|0>_s = λ|1>_f|target>__s + sqrt{1-|λ|^2}|0>_f... = sin(θ)|1>_f|target>__s + cos(θ)|0>_f...,
	/// this operation prepares the state AmpAmpByOracle|0>_f|0>_s = sin(2*iterations+1)|1>_f|target>__s + cos(2*iterations+1)|0>_f...,
	/// In most cases, "qubitFlag" and "qubitsAncilla" is initialized in the state |0>_f|0>_a.
	/// [G. Brassard, P. Hoyer, M. Mosca, A. Tapp, https://arxiv.org/abs/quant-ph/0005055]
	/// </remarks>

    
	operation AmpAmpByOracle(iterations: Int, oracleState : OracleState, idxQubitFlag : Int, qubitsStart: Qubit[]) : ()
	{
		Body {
			let phases = AmpAmpPhasesStandard(iterations)

			AmpAmpByOraclePhases(phases, oracleState, idxQubitFlag, qubitsStart)
		}

		Adjoint auto
		Controlled auto
		Adjoint Controlled auto
	}

	/// <summary>
	/// Fixed-Point Amplitude Amplification algorithm
	/// </summary>
	/// <param name = "oracleStatePrep"> Unitary oracle that prepares start state </param>
	/// <param name = "qubitsStart"> Qubit register </param>
	/// <remarks> 
	/// qubitsStart must be in the |0..0> state. This iterates over a number of queries in powers of 2 until queriesMax 
	/// is reached, or the target state is found.
	/// </remarks>
	operation AmpAmpRUSByOracle(oracleStatePrep : OracleState, qubitsStart: Qubit[]) : ()
	{
		Body {
			let queriesMax = 999 // Should be a power of 2
			let successMin = 0.99
			mutable finished = Zero
			mutable exponentMax = 0
			mutable exponentCurrent = 0

			//Complexity: Let \theta = \mathcal{O}(\sqrt{lambda}) 
			// Number of Measurements = O( Log^2(1/\theta) )
			// Number of Queries = O(1/\theta)
		
			using( qubitFlag = Qubit[1] ){
				let qubits = qubitFlag + qubitsStart
				let idxQubitFlag = 0
				repeat { 
					if( 2^exponentMax > queriesMax ){
						fail("Target state not found. Maximum number of queries exceeded.")
					}
					repeat { 
						let queries = 2^exponentCurrent
						let phases = AmpAmpPhasesFixedPoint( queries, successMin ) 
						AmpAmpByOraclePhases(phases, oracleStatePrep, idxQubitFlag, qubits)

						set finished = M(qubitFlag[0])
						set exponentCurrent = exponentCurrent + 1
					} 
					until(finished == One || exponentCurrent > exponentMax)
					fixup {
						// qubitFlag is already in Zero for fixup to apply
						ResetAll(qubitsStart)
					}
			
				set exponentCurrent = 0
				set exponentMax = exponentMax + 1
				} 
				until(finished == One)
				fixup {
					ResetAll(qubitsStart)
				}
			}

			//AmpAmpByOraclePhases(phases, oracleStatePrep, qubitFlag, qubitsStart)
		}
	}

}
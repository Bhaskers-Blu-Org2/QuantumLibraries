///Here we consider the smallest example of amplitude amplification
///Suppose we have a single-qbuit oracle that prepares the state
/// O |0> = \lambda |1> + \sqrt{1-|\lambda|^2} |0>
/// The goal is to amplify the |1> state
/// We can do this either by synthesizing the reflection about the start and target states ourselves,
/// We can also do it by passing the oracle for state preparation 

operation ExampleStatePrepImpl( lambda : Double[], qubitFlag : Qubit , qubitSystem : Qubit[] ) : ()
{
    Body
    {
        let rotAngle = 2 * ArcSin(lambda)
        Ry(rotAngle)
    }

}
function ExampleStatePrep( lambda : Double[] ) : OracleState
{
    return OracleState( ExampleStatePrepImpl (lambda, _, _) )

}

///In this mininal example, there are no system qubits, only a single flag qubit
/// thus we call the reflection operator 
// ReflectionTargetOracleState(idxQubitFlag : Int)
/// ReflectionStartOracleState(idxQubitFlag : Int, oracle: OracleState)
/// AmpAmpByOracle(iterations: Int, oracleStatePrep : OracleState, qubitFlag : Qubit, qubitsStart: Qubit[]) : ()
//  AmpAmpByReflectionsPhases(phases : AmpAmpReflectionPhases, refStart : OracleReflection, refTarget : OracleReflection, qubitsStart: Qubit[]) : ()
operation ExampleAAbyOracle
{
    Body{
        AmpAmpByOracle(iterations: Int, oracleStatePrep : OracleState, qubitFlag : Qubit, qubitsStart: Qubit[]) 
    }

}


operation ExampleAmpAmpByReflections(lambda : Double[], qubitFlag : Qubit) : ()
{
    Body{

        let oracle = ExampleStatePrepImpl(lambda, qubitFlag)
        let refTarget = ReflectionTargetOracleState(0)
        let refStart = ReflectionStartOracleState(0, oracle)



    }
}

operation ExampleAmpAmpExecute() : ()
{
    Body{


    }
}


//Example: Grover search

/// <summary>
/// Grover oracle from classical database
/// </summary>
/// <param name = "markedElements"> Indices to marked elements in database </param>
/// <param name = "qubitFlag"> Flag qubit </param>
/// <param name = "qubitsDatabase"> Database qubit register </param>
/// <remarks> 
/// This implements the oracle O|z>|k> = |z \oplus x_k>|k> used in the Grover search algorithm.
/// Given a database with N = 2^n elements, n is the size of the database qubit register.
/// Let x = x_0x_1...x_{N-1} be a binary string of N elements. Then x_k is 1 if k is in "markedElements" and 0 otherwise.
/// </remarks>
operation GroverOracleFromInts(markedElements : Int[],  qubitFlag: Qubit, qubitsDatabase: Qubit[]) : ()
{
	Body{
		let nQubits = Length(qubitsDatabase)
		let nMarked = Length(markedElements)
		for(idxMarked in 0..nMarked - 1){
			ControlledOnInt(markedElements[idxMarked], ApplyToEachAC(X, _), qubitsDatabase, [qubitFlag])
		}

	}	
	Adjoint auto
	Controlled auto
	Adjoint Controlled auto
}


/// <summary>
/// State preparation of marked stated from Grover oracle
/// </summary>
/// <param name = "markedElements"> Indices to marked elements in database </param>
/// <param name = "qubitFlag"> Flag qubit </param>
/// <param name = "qubitsDatabase"> Database qubit register </param>
/// <remarks> 
/// This implements an oracle that prepares the start state O|0>_f|0>_d = |s>_fd = \sqrt{M/N}|1>_f|marked>_d + ... |0>_f|unmarked>_d.
/// M is the length of "markedElements"
/// N is 2^n, where n is the number of database qubits.
/// </remarks>
operation GroverOracleStatePrepImpl(markedElements : Int[], qubitFlag: Qubit , qubitsDatabase: Qubit[]) : ()
{
	Body{
		let nQubits = Length(qubitsDatabase)

		ApplyToEachAC(H, qubitsDatabase)

		GroverOracleFromInts(markedElements, qubitFlag, qubitsDatabase)

	}

	Adjoint auto
	Controlled auto
	Adjoint Controlled auto
}

function GroverOracleStatePrep(markedElements : Int[]) : OracleState
{
	return OracleState(GroverOracleStatePrepImpl(markedElements, _, _))
}

/// <summary>
/// Grover search algorithm
/// </summary>
/// <param name = "markedElements"> Indices to marked elements in database </param>
/// <param name = "iterations"> Number of applications of Grover iterate </param>
/// <param name = "qubitFlag"> Flag qubit </param>
/// <param name = "qubitsDatabase"> Database qubit register </param>
/// <remarks> 
/// On input |0>_f|0>_d, this prepares the state |1>_f|marked>_d with amplitude Sin((2*iterations + 1) ArcSin(Sqrt(M/N))).
/// </remarks>
operation GroverSearch( markedElements: Int[], iterations: Int, qubitFlag: Qubit , qubitsDatabase: Qubit[]) : ()
{
	Body{ 
        AmpAmpByOracle(iterations, GroverOracleStatePrep(markedElements), qubitFlag, qubitsDatabase) 
	}

	Adjoint auto
	Controlled auto
	Adjoint Controlled auto
}
//FIXME Qb Bug #692
//Adjoint auto
//Controlled auto
//Adjoint Controlled auto

/// <summary>
/// Grover search algorithm
/// </summary>
/// <param name = "markedElements"> Indices to marked elements in database </param>
/// <param name = "iterations"> Number of applications of Grover iterate </param>
/// <param name = "nQubits"> Number of database qubits </param>
/// <remarks> 
/// This prepares the state |1>_f|marked>_d with amplitude Sin((2*iterations + 1) ArcSin(Sqrt(M/N))), measures all registers, and returns the value of the flag qubit and the value of the database register as an integer.
/// 2^qubitsDatabase should be larger than the largest integer in "markedElements"
/// </remarks>
operation GroverSearchMeasure( markedElements: Int[], iterations: Int, nQubits : Int) : (Result, Int)
{
    Body{ 

        mutable result = Zero
        mutable bits  = new Result[nQubits]
		mutable foundIndex = 0

		using(qubits = Qubit[1 + nQubits]){
			let qubitFlag = qubits[0]
			let qubitsDatabase = qubits[1..nQubits - 1]

			GroverSearch(markedElements, iterations, qubitFlag, qubitsDatabase) 

			set result = M(qubitFlag)
			set bits = MultiM(qubitsDatabase)

		   ResetAll(qubits)
           
		}
		set foundIndex = PositiveIntFromResultString(bits)
        
        return (result, foundIndex)

	}
}

/// <summary>
/// Test random instances of Grover search
/// </summary>
/// <param name = "maxMarkedElements"> Maximum number of marked elements in database </param>
/// <param name = "maxGroverIterations"> Maximum number of applications of Grover iterate </param>
/// <param name = "maxQubits"> Maximum number of database qubits </param>
/// <remarks> 
/// This generates 100 random instances of Grover search, each time by choosing a random number of database qubits n, a random number of marked elements M <= N = 2^maxQubits, and a random number of Grover iterations 
/// The success probability of measuring the flag qubit in the |1>_f state is compared to the theory of
/// Sin((2*iterations + 1) ArcSin(Sqrt(M/N)))^2
/// </remarks>
operation GroverTest( maxMarkedElements : Int, maxGroverIterations : Int , maxQubits: Int) :()
{
	Body {
		
		let nRepeats = 100
		mutable nElements = 0
		mutable nMarked = 0
		mutable nIterations = 0
		mutable nQubits = 0
		mutable markedElements = new Int[maxMarkedElements]
		mutable successAmplitude = 0.0
		for(idxRepeat in 0..nRepeats - 1)
		{
			set nMarked = randomInt(maxMarkedElements) + 1
			set nIterations = randomInt(maxGroverIterations) + 1
			set nQubits = randomInt(maxQubits) + 1
			set nElements = 2^nQubits - 1
			for(idxElement in 0..nMarked - 1){
				set markedElements[idxElement] = randomInt(nElements)
			}

			set successAmplitude = Sin( Float(2*nIterations + 1) * ArcSin( Sqrt(Float(nMarked) / Float(nElements)) ))

			using(qubits = Qubit[1 + nQubits]){
				let qubitFlag = qubits[0]
				let qubitsDatabase = qubits[1..nQubits - 1]

				GroverSearch(markedElements[0..nMarked-1], nIterations, qubitFlag, qubitsDatabase) 

				AssertProb([Zpauli], [qubitFlag], One, successAmplitude * successAmplitude, "Error: Success probability does not match theory", 1e-10)


				ResetAll(qubits)
			}

		}


		//
	}
}

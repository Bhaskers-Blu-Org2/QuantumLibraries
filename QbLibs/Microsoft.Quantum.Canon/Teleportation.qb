namespace Microsoft.Quantum.Canon {
    open Microsoft.Quantum.Primitive

    /// <summary>
    /// Teleportation transfers 1 quantum bit by encoding it into 2 classical bits, using 1 EPR pair ("1q=2c+1e").
    /// Always returns source qubit to |0>
    /// </summary>
    /// <param name = "source"> A single qubit that is in an unknown state and which gets teleported. </param>
    /// <param name = "target"> A single qubit that is initially zero and which holds the state of source at the end of the protocol. </param>
    /// <remarks>  The circuit first creates an EPR pair between the target qubit and an ancilla qubit that gets allocated inside the 
    ///     function. Then a Bell measurement between the source qubit and one half of the EPR pair is performed. Finally, depending 
    ///     on the 4 possible outcomes of the Bell measurement, a correction is performed to restore the state in the target qubit.
    ///     [ Nielsen & Chuang, CUP 2000, Section 1.3.6, http://doi.org/10.1017/CBO9780511976667 ]
    /// </remarks>

    operation Teleportation (source : Qubit, target : Qubit) : () {
        Body {
            // Get a temporary qubit for the Bell pair
            using (ancillaRegister = Qubit[1]) {
                let ancilla = ancillaRegister[0]
            
                // Create a Bell pair between the temporary qubit and the target
                Assert([Zpauli], [target], Zero, "Error: target qubit must be initialized in zero state")
                H(ancilla)
                CNOT(ancilla, target)
                Assert([Zpauli; Zpauli], [ancilla; target], Zero, "Error: EPR state must be eigenstate of ZZ")
                Assert([Xpauli; Xpauli], [ancilla; target], Zero, "Error: EPR state must be eigenstate of XX")
            
                // Perform the Bell measurement and the correction necessary to reconstruct the input state as the target state
                CNOT(source, ancilla)
                H(source)
                AssertProb([Zpauli], [source], Zero, 0.5, "Error: All outcomes of the Bell measurement must be equally likely", 1e-10)
                AssertProb([Zpauli], [ancilla], Zero, 0.5, "Error: All outcomes of the Bell measurement must be equally likely", 1e-10)  
                if ( MResetZ(source) == One ) {
                    Z(target)
                }
                if ( MResetZ(ancilla) == One ) {
                    X(target)
                }
            }
        }
    }

    operation TeleportationTest () : () {
        Body {
            // given that there is randomness involved in the Teleportation, repeat the tests several times.
            for( i in 1 .. 8 )
            {
                using (qubits1 = Qubit[2]) { 
                    // create a |+> state in the first qubit
                    H(qubits1[0])
                    Teleportation(qubits1[0], qubits1[1])
                    Assert([Xpauli], [qubits1[1]], Zero, "Error: state after the teleportation must be |+> state]")
                    ApplyToEach(Reset,qubits1)
                }
                using (qubits2 = Qubit[2]) { 
                    // create a |-> state in the first qubit
                    X(qubits2[0])
                    H(qubits2[0])
                    Teleportation(qubits2[0], qubits2[1])
                    Assert([Xpauli], [qubits2[1]], One, "Error: state after the teleportation must be |-> state]")
                    ApplyToEach(Reset,qubits2)
                }
            }
        }
    }

}
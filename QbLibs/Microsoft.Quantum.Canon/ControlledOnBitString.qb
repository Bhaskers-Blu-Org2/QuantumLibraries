//namespace Microsoft.Quantum.Canon


/// <summary>
/// Applies a unitary operator on the target register if the control register state corresponds to a specified bit mask.
/// </summary>
/// <param name = "bits"> Boolean array </param>
/// <param name = "oracle"> Unitary operator </param>
/// <param name = "qubitsTarget"> Quantum register acted on by "oracle" </param>
/// <param name = "qubitsControl"> Quantum register that controls application of "oracle" </param>
/// <remarks> 
/// The length of bits and qubitsTarget must be equal.
/// For example, bits = [0,1,0,0,1] means that "oracle" is applied if and only if "qubitsControl" is in the state |0>|1>|0>|0>|1>.
/// </remarks>
//FIXME Make this generic in the oracle A, C, AC
operation ControlledOnBitStringImpl(bits : Bool[] , oracle: (Qubit[] => (): Adjoint, Controlled), qubitsControl : Qubit[], qubitsTarget: Qubit[]) : ()
{
	Body{
		WithAC(ApplyPauliFromBitString(Xpauli, false, bits, _), (Controlled oracle)(_, qubitsTarget), qubitsControl)
		
	}

	Adjoint auto
	Controlled auto
	Adjoint Controlled auto
}
function ControlledOnBitString(bits : Bool[] , oracle: (Qubit[] => (): Adjoint, Controlled)) : ((Qubit[],Qubit[]) => (): Adjoint, Controlled)
{
	return ControlledOnBitStringImpl(bits, oracle, _, _)
}

/// <summary>
/// Applies a unitary operator on the target register if the control register state corresponds to a specified positive integer.
/// </summary>
/// <param name = "numberState"> Positive integer </param>
/// <param name = "oracle"> Unitary operator </param>
/// <param name = "qubitsTarget"> Quantum register acted on by "oracle" </param>
/// <param name = "qubitsControl"> Quantum register that controls application of "oracle" </param>
/// <remarks> 
/// "numberState" msut be at most 2^Length(qubitsTarget) - 1.
/// For example, numberState = 537 means that "oracle" is applied if and only if "qubitsTarget" is in the state |537>.
/// </remarks>
//FIXME Make this generic in the oracle A, C, AC
operation ControlledOnIntImpl(numberState : Int , oracle: (Qubit[] => (): Adjoint, Controlled), qubitsControl : Qubit[], qubitsTarget: Qubit[]) : ()
{
	Body{

		let bits = BoolArrFromPositiveInt(numberState, Length(qubitsControl))

		(ControlledOnBitString(bits, oracle))(qubitsControl, qubitsTarget)

	}

	Adjoint auto
	Controlled auto
	Adjoint Controlled auto
}
function ControlledOnInt(numberState : Int , oracle: (Qubit[] => (): Adjoint, Controlled)) : ((Qubit[],Qubit[]) => (): Adjoint, Controlled)
{
	return ControlledOnIntImpl(numberState, oracle, _, _)
}
/// <summary>
///     Reorders the qubits in a register to obtain a new
///     qubit register.
/// </summary>
operation (Qubit[]) ReverseRegister(Qubit[] register) {
    body {
        // FIXME: not currently in spec, but still compiles.
        new Qubit[length(register)] reversed

        for (idxQubit in 0..length(register) - 1) {
            let Qubit thisQubit = register[idxQubit]
            set reversed[idxQubit] <- thisQubit
        }

        return reversed
    }

    adjoint none
    controlled none
}

/// <summary>
///     Uses SWAP gates to reverse the order of the qubits in
///     a register.
/// </summary>
operation () SwapReverseRegister(Qubit[] register) {
    body {
        // TODO
    }

    adjoint self
    controlled auto
}

newtype (Qubit[]) LittleEndian
newtype (Qubit[]) BigEndian

// The next two operations are just to specify the more
// specific user-defined types LE and BE so that we can partially apply
// to obtain (LittleEndian => ()) instead of (Qubit[] => ()).

// NB: If Q♭ supported co- and contravariance of operation
//     types, we could handle both the little → big and
//     big → little cases by writing an operation
//     of the form ((Qubit[]) => ()) => ((Qubit[]) => ())
//     and then writing two wrappers to handle the
//     appropriate UDTs. (Though the types left of => would
//     still be fun.)
//
//     In lieu of this, we can do some fun with using
//     let to bind LittleEndian to Qubit[] then partially
//     applying a call to ApplyReversedOp.

operation () ApplyReversedOpLE((LittleEndian => ()) op, BigEndian register) {
    body {
        let Qubit[] bareRegister = register
        let Qubit[] bareReversed = ReverseRegister(bareRegister)
        let LittleEndian reversed = LittleEndian(bareReversed)
        op(reversed)
    }
}

operation () ApplyReversedOpBE((BigEndian => ()) op, LittleEndian register) {
    body {
        let Qubit[] bareRegister = register
        let Qubit[] bareReversed = ReverseRegister(bareRegister)
        let BigEndian reversed = BigEndian(bareReversed)
        op(reversed)
    }
}

// We finish by providing two wrappers that partially
// apply the two operations above for convenience.
operation (BigEndian => ()) LittleOpToBigOp((LittleEndian => ())  op) {
    body {
        return ApplyReversedOpLE(op, _)
    }
}

operation (LittleEndian => ()) BigOpToLittleOp((BigEndian => ())  op) {
    body {
        return ApplyReversedOpBE(op, _)
    }
}

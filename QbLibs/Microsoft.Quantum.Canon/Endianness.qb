/// <summary>
///     Reorders the qubits in a register to obtain a new
///     qubit register.
/// </summary>
operation (Qubit[]) ReverseRegister(Qubit[] register) {
    Body {
        mutable reversed = new Qubit[Length(register)]

        for (idxQubit in 0..Length(register) - 1) {
            let thisQubit = register[Length(register) - idxQubit + 1]
            set reversed[idxQubit] = thisQubit
        }

        return reversed
    }
}

/// <summary>
///     Uses SWAP gates to reverse the order of the qubits in
///     a register.
/// </summary>
operation () SwapReverseRegister(Qubit[] register) {
    Body {
        // TODO
    }

    Adjoint self
    Controlled auto
    Controlled Adjoint auto
}

newtype (Qubit[]) LittleEndian
newtype (Qubit[]) BigEndian

// The next two operations are just to specify the more
// specific user-defined types LE and BE so that we can partially apply
// to obtain (LittleEndian => ()) instead of (Qubit[] => ()).

operation () ApplyReversedOpLE((LittleEndian => ()) op, BigEndian register) {
    Body {
        let bareReversed = ReverseRegister(register)
        let reversed = LittleEndian(bareReversed)
        op(reversed)
    }
}

operation () ApplyReversedOpBE((BigEndian => ()) op, LittleEndian register) {
    Body {
        let bareReversed = ReverseRegister(register)
        let reversed = BigEndian(bareReversed)
        op(reversed)
    }
}

// We finish by providing two wrappers that partially
// apply the two operations above for convenience.
operation (BigEndian => ()) LittleOpToBigOp((LittleEndian => ())  op) {
    Body {
        return ApplyReversedOpLE(op, _)
    }
}

operation (LittleEndian => ()) BigOpToLittleOp((BigEndian => ())  op) {
    Body {
        return ApplyReversedOpBE(op, _)
    }
}

///<summary> 
/// Iterates a variable, say arr, through cartesian product 
/// [ 0, bounds[0]-1 ] × [ 0, bounds[1]-1 ] × [ 0, bounds[Length(bounds)-1]-1 ]
/// and calls op(arr) for every element of the cartesian product
///</summary>
operation IterateThroughCartesianProduct( bounds : Int[], op : ((Int[]) => ()) ) : ()
{
	Body
	{
		mutable arr = new Int[Length(bounds)]
		mutable finished = false
		repeat
		{
			op(arr)
		}
		until(finished)
		fixup
		{
			//computes the next element in the cartesian product
			set arr[0] = arr[0] + 1
			for( i in 0 .. Length(arr) -2 )
			{
				if( arr[i] == bounds[i] )
				{
					set arr[i+1] = arr[i+1] + 1
					set arr[i] = 0
				}
			}
			if( arr[Length(arr) -1] == bounds[Length(arr) -1] )
			{
				set finished = true
			}
		}
	}
}

///<summary>
/// Creates an array of given length with all elments equal to given value
///</summary>
function MakeConstArray( length : Int, value : Int ) : Int[]
{
	mutable arr = new Int[length]
	for( i in 0 .. length - 1 )
	{
		set arr[i] = value
	}
	return arr
}

///<summary> 
/// Iterates a variable, say arr, through cartesian product 
/// [ 0, bound - 1 ] × [ 0, bound - 1 ] × [ 0, bound - 1 ]
/// and calls op(arr) for every element of the cartesian product
///</summary>
operation IterateThroughCartesianPower( power : Int, bound : Int, op : ((Int[]) => ()) ) : ()
{
	Body
	{
		IterateThroughCartesianProduct(MakeConstArray(power,bound),op)
	}
}
namespace Microsoft.Quantum.Canon {
    open Microsoft.Quantum.Primitive

    /// summary:
    ///     Performs the robust non-terative quantum phase estimation algorithm for a given oracle U and eigenstate,
    ///     and provides a single real-valued estimate of the phase with variance scaling at the Heisenberg limit.
    /// params:
    ///     oracle: An operation implementing U^m for given integer powers m.
    ///     eigenstate: A quantum register representing an eigenstate |φ> of U, U|φ> =
    ///         e^{iφ} |φ> for φ ∈ [0, 2π) an unknown phase.
    ///     bitsPrecision: This provides an estimate of φ with standard deviation
    ///         σ <= 2π / 2^bitsPrecision using Queries scaling like σ <= 10.7 Pi/ Queries.
    ///</param>
    /// remarks:
    ///     From Cramer-Rao lower bounds, the standard deviation also satisfies σ >= 2.0 Pi / Queries.
    /// citation:
    ///     Robust Calibration of a Universal Single-Qubit Gate-Set via Robust Phase Estimation
    ///     Shelby Kimmel, Guang Hao Low, Theodore J. Yoder
    ///     https://arxiv.org/abs/1502.02677
    // FIXME: Non-adaptive version requires Modulo for real numbers
    // FIXME: Cramér–Rao bounds only apply in unbiased case; change documentation to use van Trees inequaltiy!!!
    operation RobustPhaseEstimation(bitsPrecision : Int, oracle : DiscreteOracle, eigenstate : Qubit[])  : Double
    {
        Body {
            let alpha = 2.5
            let beta = 0.5
            mutable thetaEst = ToDouble(0)

            using (qubitAncilla = Qubit[1]) {
                let q = qubitAncilla[0]

                for (exponent in 0..bitsPrecision - 1) {

                    let power = 2 ^ (exponent)
                    mutable nRepeats = Ceiling(alpha * ToDouble(bitsPrecision - exponent) + beta)
                    if(nRepeats % 2 == 1){
                        set nRepeats = nRepeats + 1
                    }

                    mutable pZero = ToDouble(0)
                    mutable pPlus = ToDouble(0)

                    for (rep in 0..repeats-1) {
                        // FIXME: Write this in terms of the existing PhaseEstimationIteration
                        //        to allow for generaliztion over PE algorithms.
                        //        This requires figuring out how to separate |+〉 and |0〉 exps.
                        Reset(q)
                        H(q)
                        (Controlled oracle)([q], (power, eigenstate))
                        Rz( thetaEst * ToDouble(power), q)
                        H(q)
                        let resultZero = M(q)
                        if(resultZero == Zero){
                            set pZero = pZero + 1.0
                        }
                        Reset(q)
                        H(q)
                        (Controlled oracle)([q], (power, eigenstate))
                        Rz(Pi() / 2.0 + thetaEst * ToDouble(power), q)
                        H(q)
                        let resultPlus = M(q)
                        if(resultPlus == Zero){
                            set pPlus = pPlus + 1.0
                        }
                    }
                    // For non-adative, remove thetaEst * ToDouble(power) and
                    // delta = Mod[ArcTan2(pPlus - ToDouble(repeats) / 2.0,  pZero - ToDouble(repeats) / 2.0), 2 Pi(), -Pi()]
                    // thetaEst = theteaEst + delta / power

                    let thetaDelta = ArcTan2(pPlus - ToDouble(repeats) / 2.0,  pZero - ToDouble(repeats) / 2.0)
                    set thetaEst = thetaEst + thetaDelta / ToDouble(power)
                }
                Reset(q)
            }
            return thetaEst
        }
    }


    operation RobustPhaseEstimationTestOp(phase: Double, power: Int, qubits : Qubit[]) : (){
        Body{
            Rz(2.0* phase * ToDouble(power), qubits[0])
        }
        Adjoint auto
        Controlled auto
        Controlled Adjoint auto
    }

    operation RobustPhaseEstimationTest2() : Double {
        Body{
            let phaseSet = 0.34545
            mutable phaseEst = 0.123
            let bitsPrecision = 10
            let op = DiscreteOracle(RobustPhaseEstimationTestOp(phaseSet, _, _))
            using (q = Qubit[1]) {

                set phaseEst = RobustPhaseEstimation(bitsPrecision, op, q)

                Reset(q[0])

                //Rx(phaseSet , q[0])

                //let prob = Sin((phaseEst-phaseSet) * 0.5) * Sin((phaseEst-phaseSet) * 0.5)


                //AssertProb([Zpauli], [q[0]], One, 0.123, "Phase error large",  1e-10)

                //ReadReal(phaseEst)

                Reset(q[0])


            }

            let output2 = 10.0 * phaseEst

            return output2

        }
    }

    function testMutable() : Double {
        mutable var = 10.0
        return var
    }

    operation RobustPhaseEstimationDemo(phaseSet : Double, bitsPrecision: Int) : Double{
        Body{
            let op = DiscreteOracle(RobustPhaseEstimationTestOp(phaseSet, _, _))
            mutable phaseEst = ToDouble(0)
            using(q= Qubit[1]){
                set phaseEst = RobustPhaseEstimation(bitsPrecision, op, q)
                Reset(q[0])
            }
            return phaseEst
        }
    }

    operation RobustPhaseEstimationTest() : () {
        Body{
            let phaseSet = 0.34545
            let bitsPrecision = 10
            let phaseEst = RobustPhaseEstimationDemo(phaseSet, bitsPrecision)
            ReadReal(phaseEst)
        }
    }

}
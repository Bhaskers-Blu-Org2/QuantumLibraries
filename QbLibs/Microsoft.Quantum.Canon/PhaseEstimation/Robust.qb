namespace Microsoft.Quantum.Canon {
    open Microsoft.Quantum.Primitive

    /// <summary>
    ///     Performs the robust non-terative quantum phase estimation algorithm for a given oracle U and eigenstate,
    ///     and provides a single real-valued estimate of the phase with variance scaling at the Heisenberg limit
    /// </summary>
    /// <param name="oracle">An operation implementing U^m for given integer powers m.</param>
    /// <param name="eigenstate">A quantum register representing an eigenstate |φ> of U, U|φ> =
    ///     e^{iφ} |φ> for φ ∈ [0, 2π) an unknown phase.</param>
    /// <param name="bitsPrecision"> This provides an estimate of φ with 
    /// standard deviation σ <= 2π / 2^bitsPrecision using Queries scaling like σ <= 10.7 Pi/ Queries.
    /// From Cramer-Rao lower bounds, the standard deviation also satisfies σ >= 2.0 Pi / Queries
    ///</param>
    /// <remarks>
    /// Robust Calibration of a Universal Single-Qubit Gate-Set via Robust Phase Estimation
    /// Shelby Kimmel, Guang Hao Low, Theodore J. Yoder
    /// https://arxiv.org/abs/1502.02677
    /// </remarks>
    ///FIXME Non-adaptive version requires Modulo for real numbers
    operation RobustQuantumPhaseEstimation(bitsPrecision : Int, oracle : DiscreteOracle, eigenstate : Qubit[])  : Double
    {
        Body {
            let alpha = 2.5
            let beta = 0.5
            mutable thetaEst = ToDouble(0)
            using(qubitAncilla = Qubit[1]){
                let q = qubitAncilla[0]

                for(exponent in 0..bitsPrecision-1){
                    

                    let power = 2 ^ (exponent)
                    mutable repeats = Ceiling(alpha * ToDouble(bitsPrecision - exponent) + beta)
                    if(repeats % 2 == 1){
                        set repeats = repeats + 1
                    }

                    mutable pZero = ToDouble(0)
                    mutable pPlus = ToDouble(0)

                    for (rep in 0..repeats-1){
                        Reset(q)
                        H(q)
                        (Controlled oracle)([q], (power, eigenstate))
                        Rz( thetaEst * ToDouble(power), q)
                        H(q)
                        let resultZero = M(q)
                        if(resultZero == Zero){
                            set pZero = pZero + 1.0
                        }
                        Reset(q)
                        H(q)
                        (Controlled oracle)([q], (power, eigenstate))
                        Rz(Pi() / 2.0 + thetaEst * ToDouble(power), q)
                        H(q)
                        let resultPlus = M(q)
                        if(resultPlus == Zero){
                            set pPlus = pPlus + 1.0
                        }
                    }
                    ///For non-adative, remove thetaEst * ToDouble(power) and
                    /// delta = Mod[ArcTan2(pPlus - ToDouble(repeats) / 2.0,  pZero - ToDouble(repeats) / 2.0), 2 Pi(), -Pi()]
                    /// thetaEst = theteaEst + delta / power

                    let thetaDelta = ArcTan2(pPlus - ToDouble(repeats) / 2.0,  pZero - ToDouble(repeats) / 2.0)
                    set thetaEst = thetaEst + thetaDelta / ToDouble(power)
                }
                Reset(q)
            }
            return thetaEst
        }
    }


    operation RobustQuantumPhaseEstimationTestOp(phase: Double, power: Int, qubits : Qubit[]) : (){
        Body{
            Rz(2.0* phase * ToDouble(power), qubits[0])
        }
        Adjoint auto
        Controlled auto
        Controlled Adjoint auto
    }

    operation RobustQuantumPhaseEstimationTest() : (){
        Body{
            let phaseSet = 1.34545
            let bitsPrecision = 10
            let op = DiscreteOracle(RobustQuantumPhaseEstimationTestOp(phaseSet * 1.0, _, _))
            using(q= Qubit[1]){
            
                let phaseEst = RobustQuantumPhaseEstimation(bitsPrecision, op, q)


                Rx(phaseSet - phaseEst, q[0])
            
                let prob = Sin((phaseEst-phaseSet) * 0.5) * Sin((phaseEst-phaseSet) * 0.5)

                AssertProb([Zpauli], [q[0]], Zero, 1.0, "Phase error large",  1e-5)


                Reset(q[0])


            }
        }
    }

}
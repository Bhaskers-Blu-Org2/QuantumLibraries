
/// <summary>
///     Private operation used to implement both the bit flip encoder and decoder.
/// 
///     Note that this encoder can make use of in-place coherent recovery,
///     in which case it will "cause" the error described
///     by the initial state of <param>auxQubits</param>.
///     In particular, if <param>auxQubits</param> are initially in the state |10〉, this
///     will cause an X₁ error on the encoded qubit.
/// <cite doi="10.1103/PhysRevA.85.044302" />
/// </summary>
operation BFEncoderImpl(coherentRecovery : Bool, data : Qubit[], scratch : Qubit[])  : ()
{
    Body {
        if (coherentRecovery) {
            (Controlled(X))(scratch, data[0])
        }
        (Controlled(X))(data, scratch[0])
        (Controlled(X))(data, scratch[1])
    }

    Adjoint auto
}

/// <summary>
///     Encodes into the [3, 1, 3] / ⟦3, 1, 1⟧ bit-flip code.
/// </summary>
// TODO: document parameters
operation BitFlipEncoder(physRegister : Qubit[], auxQubits : Qubit[])  : LogicalRegister
{
    Body {
        BFEncoderImpl(false, physRegister, auxQubits)
        
        let logicalRegister = LogicalRegister(physRegister + auxQubits)
        return logicalRegister
    }
}

operation BitFlipDecoder( logicalRegister : LogicalRegister)  : (Qubit[], Qubit[])
{
    Body {
        let physRegister = [logicalRegister[0]]
        let auxQubits = logicalRegister[1..2]

        (Adjoint BFEncoderImpl)(false, physRegister, auxQubits)

        return (physRegister, auxQubits)
    }
}

/// <summary>
///     Returns a QECC value representing the ⟦3, 1, 1⟧ bit flip code encoder and
///     decoder with in-place syndrome measurement.
/// </summary>
operation  BitFlipCode()  : QECC
{
    Body {
        let e = EncodeOp(BitFlipEncoder)
        let d = DecodeOp(BitFlipDecoder)
        let s = SyndromeMeasOp(MeasureStabilizerGenerators([[Zpauli; Zpauli; Ipauli]; [Ipauli; Zpauli; Zpauli]], _, MeasureWithScratch))
        let code = QECC(e, d, s)
        return code
    }
}

function  BitFlipRecoveryFn()  : RecoveryFn
{
    return TableLookupRecovery([[Ipauli; Ipauli; Ipauli]; [Ipauli; Ipauli; Xpauli]; [Xpauli; Ipauli; Ipauli]; [Ipauli; Xpauli; Ipauli]])
}


// !!! EXAMPLE !!! //

/// <summary>
///     Given a quantum error-correcting code, a number of scratch qubits, a recovery function,
///     and some qubit data to be protected, demonstrates the use of the code by causing and then
///     correcting a single error.
/// </summary>
operation CodeExample( code : QECC, nScratch : Int,  fn : RecoveryFn, data : Qubit[])  : ()
{
    Body {
        let (encode, decode, syndMeas) = BitFlipCode()
        using (scratch = Qubit[nScratch]) {
            let logicalRegister = encode(data, scratch)
            // Cause an error.
            X(logicalRegister[0])
            Recover(code, fn, logicalRegister)
            let decodedRegisters = decode(logicalRegister)
            // TODO: assert that we corrected OK here.
        }
    }
}

/// <summary>
///     An example of how to call CodeExample with the bit flip code and the default recovery function.
/// </summary>
operation BFExample()  : ()
{
    Body {
        let code = BitFlipCode()
        let fn = BitFlipRecoveryFn()

        using (data = Qubit[1]) {
            CodeExample(code, 2, fn, data)
        }
    }
}


// Overview of amplitude amplification library
// Oblivious amplitude amplification with partial reflections is the most general form of amplitude amplification implemented here
// This is called through the operation AmpAmpObliviousByReflectionPhases.
//		This has two registers: "qubitsAncilla" and "qubitsSystem".
//		This accepts two oracles for these reflections of type "OracleReflection" which act only on the "qubitsAncilla" register.
//		This accepts an oracle special to oblivious amplitude amplification of type "OracleOblivious" which acts jointly on both register.
//		The input state to "qubitsAncilla" is assumed to be the unique -1 eigenstate of the first reflection operator.
//
// Reflections about a quantum state are often implemented by assuming access to an oracle that prepare that state from the computational basis |0...0>.
//		Our convention for these oracles requires two registers: a single-qubit "qubitFlag" register, and "qubitsState".
//		The oracle of type "OracleState" acts jointly on both registers to create the target state flagged by |1> in the "qubitFlag" register with some real ampitude. 
//		The reflection "OracleReflection" about the this flag state is generated by the operation "ReflectionTargetForOracleState"
//		The reflection "OracleReflection" about the input state to "qubitsAncilla" is generated by the operation "ReflectionFromOracleState"
//
// "AmpAmpObliviousByOraclePhases" is a version of oblivious amplitude amplification that accepts oracles "OracleState" and "OracleOblivious" instead of reflections.
//
// Note that amplitude amplification is a special case of oblivious amplitude amplifiction where "OracleOblivious" is the identity operator, and there are no system qubits i.e. "qubitsSystem" is empty.
//		This is called through the operaton "AmpAmByReflectionPhases" and "AmpAmpByOraclePhases".
//
// The phases for partial reflections in the standard case of Grover search is provided by the function AmpAmpPhasesGrover
//		An example
// The operation AmpAmpObliviousByReflections calls AmpAmpObliviousByReflectionPhases with phases given by AmpAmpPhasesGrover
// 

// TODO: Phases for fixed-point amplification
// TODO: Example for Grover search on database -- requires reversible function for adding bitstrings
// TODO: Unittests for amplitudeamplification routines
// TODO: Amplitude estimation -- easiest way to is to use quantum phase estimation libary on Grover Iterate as the oracle

//phasesStart, phasesTarget
newtype AmpAmpReflectionPhases = (Double[], Double[])
newtype AmpAmpRotationPhases = (Double[])

//We use the convention in "Hamiltonian Simulation by Uniform Spectral Amplification" [LowChuang2017] for relating single-qubit rotation phases to reflection operator phases
function AmpAmpRotationToReflectionPhases( rotPhases : AmpAmpRotationPhases) : AmpAmpReflectionPhases
{
	let nPhasesRot = Length(rotPhases)
	let nPhasesRef = (nPhasesRot + 1) / 2
	
	//FailOn(nPhasesRot % 2 == 0, "Number of rotations must be odd.")

	mutable phasesTarget = new Double[nPhasesRef]
	mutable phasesStart = new Double[nPhasesRef]

	set phasesTarget[0] = rotPhases[0] - rotPhases[1] - Pi()
	set phasesStart[0] = - rotPhases[0] + 0.5 * Pi()

	for (idxPhases in 1..nPhasesRef-2){
		set phasesTarget[idxPhases] = rotPhases[2*idxPhases] - rotPhases[2*idxPhases + 1] - Pi()
		set phasesStart[idxPhases] = rotPhases[2*idxPhases-1] - rotPhases[2*idxPhases] + Pi()
	}

	set phasesTarget[nPhasesRef-1] = rotPhases[2*nPhasesRef-2] - 0.5 * Pi()
	set phasesStart[nPhasesRef-1] = rotPhases[2*nPhasesRef-3] - rotPhases[2*nPhasesRef-2] + Pi()

	return AmpAmpReflectionPhases(phasesTarget, phasesStart)
}

//All phases are Pi, except for the first reflection about start and the last reflection about target, which are 0.
function AmpAmpPhasesGrover(iterations : Int) : AmpAmpReflectionPhases{
	mutable phasesTarget = new Double[iterations+1]
	mutable phasesStart = new Double[iterations+1]
		

	for (idxPhases in 0..iterations){
		set phasesTarget[idxPhases] = Pi()
		set phasesStart[idxPhases] = Pi()
	}
	set phasesTarget[iterations] = 0.0
	set phasesStart[0] = 0.0

	return AmpAmpReflectionPhases(phasesTarget, phasesStart)
}


//We use the phases in "Fixed-Point Amplitude Amplification with an Optimal Number of Queires" [YoderLowChuang2014]
//See also "Methodology of composite quantum gates" [LowYoderChuang2016] for phases in the "AmpAmpRotationPhases" format
//function AmpAmpPhasesFixedPoint( lambdaMin : double, SuccessMin: double ) : (double[], double[]){
	//TODO everything
	//let iterations = 1


	//mutable phasesTarget = new double[iterations+1]
	//mutable phasesStart = new double[iterations+1]
		
	//To be changed
	//for (idxPhases in 0..iterations){
	//	set phasesTarget[idxPhases] = Pi()
	//	set phasesStart[idxPhases] = Pi()
	//}
	//set phasesTarget[iterations] = 0.0
	//set phasesStart[0] = 0.0

	//return (phasesTarget, phasesStart)

//}

// Phase shift about |1...1><1...1|
operation ReflectionAllOnes( phase: Double, qubits: Qubit[] ) : ()
{
	Body{
		let nQubits = Length(qubits)
		let qubitFlag = qubits[0]
		let qubitsSystem = qubits[1..nQubits-1]

		(Controlled R1(phase, _))(qubitsSystem, qubitFlag)

	}

	Adjoint auto
    Controlled auto
    Controlled Adjoint auto
}

// Phase shift about |0...0><0...0|
operation ReflectionAllZero( phase: Double, qubits: Qubit[] ) : ()
{
	Body {

		WithCA(ApplyToEachAC(X, _), ReflectionAllOnes(phase, _), qubits)

	}

	Adjoint auto
    Controlled auto
    Controlled Adjoint auto
}


// This oracle O = I - (1 - e^(- i ϕ)) |ψ><ψ| performs a partial reflection by phase ϕ about a single pure state |ψ>.
// Note that when ϕ = π, O = I - 2 |ψ><ψ| is a reflection operator.
newtype OracleReflection = ((Double, Qubit[]) => (): Adjoint,Controlled)
//newtype OracleReflection = ((Double, Qubit[]) => ())

///This oracle O|s>_a|ψ>_s = λ |t>_a U |ψ>_s + ... acts on the ancilla state |s>_a to implement the unitary U on any system state |ψ>_s with amplitude λ in the |t>_a basis.
newtype OracleOblivious = ((Qubit[], Qubit[]) => (): Adjoint, Controlled)

///This oracle O|0>_f|0>_s = λ |1>_f |ψ>_s + ... acts on the on computational basis state |0>_f|0>_s to create the state |ψ>_s with amplitude λ in the basis flagged by |1>_f
newtype OracleState = ((Qubit, Qubit[]) => (): Adjoint, Controlled)

///This oracle O|0> = acts on the on computational basis state |0> to create the state |ψ>.
newtype OracleStateDeterministic = (Qubit[] => (): Adjoint, Controlled)

operation Identity1(qubits: Qubit[]) : (){
	Adjoint auto
	Controlled auto
	Adjoint Controlled auto
}
operation Identity2(qubitsA: Qubit[], qubitsB: Qubit[]) : (){
	Adjoint auto
	Controlled auto
	Adjoint Controlled auto
}


operation ReflectionStartOracleStateDeterministic(phase: Double, oracle: OracleStateDeterministic, qubitsSystem: Qubit[]): ()
{
	Body {
		(Adjoint oracle)(qubitsSystem)
		ReflectionAllZero(phase, qubitsSystem)
		oracle(qubitsSystem)
	}
	Adjoint auto
	Controlled auto
	Adjoint Controlled auto
}

operation ReflectionStartOracleState(phase: Double, oracle: OracleState, qubitFlag: Qubit, qubitsSystem: Qubit[]): ()
{
	Body {
		(Adjoint oracle)(qubitFlag, qubitsSystem)
		ReflectionAllZero(phase, qubitsSystem)
		oracle(qubitFlag, qubitsSystem)
	}
	Adjoint auto
	Controlled auto
	Adjoint Controlled auto
}

//Assumes that qubitFlag is one of qubitsAncilla
operation ReflectionTargetOracleState(phase: Double, qubitFlag: Qubit, qubitsAncilla: Qubit[]): ()
{
	Body {
		R1(phase, qubitFlag)
	}

	Adjoint auto
	Controlled auto
	Adjoint Controlled auto
}



///refstart is reflection about Flag & Signal qubits only
///reftarget is reflection about Flag & Signal qubits only
operation AmpAmpObliviousByReflectionPhases(phases : AmpAmpReflectionPhases, refAncilla : OracleReflection, refTarget : OracleReflection, oracleSignal : OracleOblivious, qubitsAncilla: Qubit[], qubitsSystem: Qubit[]) : ()
{
	Body {
		let (phasesAncilla, phasesTarget) = phases
		let nphases = Length(phasesTarget)

		//FailOn(nphases != Length(phasesAncilla), "Phase array lengths not equal.")
		
		for (idxPhases in 0..nphases - 1){
			if(phasesAncilla[idxPhases] != 0.0) {
				refAncilla(phasesAncilla[idxPhases], qubitsAncilla)
			}

			if(idxPhases%2 == 0){
				oracleSignal(qubitsAncilla, qubitsSystem)
			}
			else{
				(Adjoint oracleSignal)(qubitsAncilla, qubitsSystem)
			}
			
			if(phasesTarget[idxPhases] != 0.0) {
				refTarget(phasesTarget[idxPhases], qubitsAncilla)
			}
		}
	}
}


//Assumes that qubitFlag is one of qubitsAncilla
//Assumes that oracleSignal . oracleAncilla |0>_{a1}|0>_{a2}|system> = lambda|1>_{a1}|Phi>_{a2}U|system> + ...|0>_{a1}...
operation AmpAmpObliviousByOraclePhases(phases : AmpAmpReflectionPhases, oracleAncilla : OracleStateDeterministic, oracleSignal : OracleOblivious, qubitFlag : Qubit, qubitsAncilla: Qubit[], qubitsSystem: Qubit[]) : ()
{
	Body {
		//Assert that qubitsAncilla are in |0...0> state?
		let refAncilla = OracleReflection(ReflectionStartOracleStateDeterministic(_, oracleAncilla, _))
		let refTarget = OracleReflection(ReflectionTargetOracleState(_, qubitFlag, _))
		

		AmpAmpObliviousByReflectionPhases(phases, refAncilla, refTarget, oracleSignal, qubitsAncilla, qubitsSystem)
		
	}
}


//Amplitude amplification is a special case of oblivous amplitude amplification.
//User provides a unitary "refTarget" that reflects about the target state |t>, a unitary "refStart" that reflects about the start state |s>, and qubits "qubitsStart" initialized in the start state |s>.
operation AmpAmpByReflectionsPhases(phases : AmpAmpReflectionPhases, refStart : OracleReflection, refTarget : OracleReflection, qubitsStart: Qubit[]) : ()
{
	Body {
		//Pass empty qubit array using fact that Identity2 does nothing
		let qubitEmpty = new Qubit[0]

		let oracleSignal = OracleOblivious(Identity2)

		AmpAmpObliviousByReflectionPhases(phases, refStart, refTarget, oracleSignal, qubitsStart, qubitEmpty) 
	}
}


//Assumes that qubitFlag is one of qubitsStart
//Assumes that oracleState |0>_{a1}|0>_{a2}|system> = lambda|1>_{a1}|Phi>_{a2}U|system> + ...|0>_{a1}...
operation AmpAmpByOraclePhases(phases : AmpAmpReflectionPhases, oracleStatePrep : OracleState, qubitFlag : Qubit, qubitsStart: Qubit[]) : ()
{
	Body {
		//Assert that qubitsAncilla are in |0...0> state?
		let refStart = OracleReflection(ReflectionStartOracleState(_, oracleStatePrep, qubitFlag, _))
		let refTarget = OracleReflection(ReflectionTargetOracleState(_, qubitFlag, _))
		
		AmpAmpByReflectionsPhases(phases, refStart, refTarget, qubitsStart)
	}
}


//Standard Amplitude Amplification algorithm
operation AmpAmpByOracle(iterations: Int, oracleStatePrep : OracleState, qubitFlag : Qubit, qubitsStart: Qubit[]) : ()
{
	Body {
		let phases = AmpAmpPhasesGrover(iterations)

		AmpAmpByOraclePhases(phases, oracleStatePrep, qubitFlag, qubitsStart)
	}
}


//Example: Grover search
operation GroverSearch(iterations: Int, elements: Int, elementAddresses: Int[]) : ()
{
	Body{
		//TODO needs adder circuit |z>|x> = |z \oplus elements[x]>|x>
	}
}